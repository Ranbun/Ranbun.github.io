<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Boy</title>
    <url>/2021/03/16/baozi/</url>
    <content><![CDATA[<h4 id="about-this-blog">About this Blog</h4>
<ul>
<li>个人博客，分享我的日常与一些工作内容</li>
</ul>
<span id="more"></span>
]]></content>
      <categories>
        <category>bun</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>intraduce</tag>
      </tags>
  </entry>
  <entry>
    <title>Bit manipulation</title>
    <url>/2022/07/29/C++/Bit-manipulation/</url>
    <content><![CDATA[<h3 id="将二进制数某一位置0置1取反">将二进制数某一位置0，置1，取反</h3>
<ul>
<li>用位运算可以解决我们的问题,所以下面部分的代码就是一些位运算的简单应用</li>
</ul>
<span id="more"></span>
<ul>
<li>函数实现</li>
</ul>
<h4 id="将不同进制数转为二进制非必须---我们只是为了显示结果">1.
将不同进制数转为二进制(非必须) - 我们只是为了显示结果</h4>
<ul>
<li>模拟人的计算过程 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">showBinary</span><span class="params">(<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> std::cout;</span><br><span class="line">    <span class="keyword">using</span> std::endl;</span><br><span class="line">    <span class="keyword">using</span> std::array;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储具体对应的位的值 0 / 1</span></span><br><span class="line">    array&lt;<span class="type">int</span>, 32&gt; num;</span><br><span class="line">    num.<span class="built_in">fill</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>; <span class="comment">// 当前转换的Bit位</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (d &amp; flag)</span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        flag = flag &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找第一个不是零的数 </span></span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">#<span class="keyword">if</span> 1 </span></span><br><span class="line">    <span class="comment">// 此过程可以省略 做了个显示上的优化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (num[i] != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"></span><br><span class="line">                i == <span class="number">0</span> ? index = i : index = i - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出转换结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = index; i &lt; num.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; num[i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="某一位置为-0">某一位置为 0</h4>
<ul>
<li><code>&amp;</code>运算的应用 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 某一位设置为 0</span></span><br><span class="line"><span class="comment">/// d 你要修改的数 </span></span><br><span class="line"><span class="comment">/// bits 你要修改的位置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">setBit2Zero</span><span class="params">(T d, <span class="type">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitManipulate::<span class="built_in">showBinary</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="comment">// 取反是一个只和取反位数以及之后所有位数相关的操作</span></span><br><span class="line">    <span class="comment">// 二进制的位数从0开始计算 所以需要 bits - 1 </span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; (bits(3) - 1) = 4 = 0100 </span></span><br><span class="line">    <span class="comment">// ~4 = 1011</span></span><br><span class="line">    <span class="comment">// &amp; 同为 1 则为 1 =&gt; 1011 &amp; (任意数字) 第三位等于 0</span></span><br><span class="line">    d = d &amp; (~(<span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span>)));</span><br><span class="line">    BitManipulate::<span class="built_in">showBinary</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="某一位置为-1">某一位置为 1</h4>
<ul>
<li><code>|</code> 运算的应用, 只要有一个是1 结果都是1
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 某一位设置为 1</span></span><br><span class="line"><span class="comment">/// d 你要修改的数 </span></span><br><span class="line"><span class="comment">/// bits 你要修改的位置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">setBit2One</span><span class="params">(T d, <span class="type">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitManipulate::<span class="built_in">showBinary</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="comment">// d(16) = 10000 bits = 3</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; bits - 1 == 4 = 0100</span></span><br><span class="line">    <span class="comment">// d | 0100 = 10000 | 0100  = 10100 </span></span><br><span class="line">    d = d | (<span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span>));</span><br><span class="line">    BitManipulate::<span class="built_in">showBinary</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="某一位置取反">某一位置取反</h4>
<ul>
<li><code>^</code> 异或运算的运用
<ul>
<li><code>^</code> 异或运算 1 ^ 0 == 1 / 0 ^ 1 == 1 其余的情况都是
0</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 某一位取反</span></span><br><span class="line"><span class="comment">/// d 你要修改的数 </span></span><br><span class="line"><span class="comment">/// bits 你要修改的位置</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">setBit2Negate</span><span class="params">(T d, <span class="type">int</span> bits)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitManipulate::<span class="built_in">showBinary</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="comment">// 转换过程</span></span><br><span class="line">    <span class="comment">// ^ 异或运算 1 ^ 0 == 1 / 0 ^ 1 == 1  其余的情况都是 0 </span></span><br><span class="line">    <span class="comment">// d(15) == 1111 bits = 3</span></span><br><span class="line">    <span class="comment">// 1 &lt;&lt; bits - 1 == 0100</span></span><br><span class="line">    <span class="comment">// 1111</span></span><br><span class="line">    <span class="comment">// 0100 ^</span></span><br><span class="line">    <span class="comment">// 1011 </span></span><br><span class="line">    d = d ^ (<span class="number">1</span> &lt;&lt; (bits - <span class="number">1</span>));</span><br><span class="line">    BitManipulate::<span class="built_in">showBinary</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d));</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="参考">参考</h2>
<ul>
<li>[1] <a
href="https://gthub.com/Ranbun/blogProjects/tree/main/BitManipulation"
title="Github">Github</a></li>
</ul>
]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Cplusplus key words - extern</title>
    <url>/2022/08/08/C++/Cplusplus-key-words-extern/</url>
    <content><![CDATA[<p>
  <code>cpp</code>关键词之<code>extern</code>...
</p>
<span id="more"></span>
<center>
<h2>
<code>extern</code>关键字
</h2>
</center>
<h2 id="extern-初解"><code>Extern</code> 初解</h2>
<ul>
<li>关于<code>extern</code>关键字可以应用于全局变量、函数或模板声明。它指定符号具有外部链接性质。
<ul>
<li>在非const 全局变量声明中， extern
指定变量或函数在另一个转换单元中定义。
extern必须在定义变量的所有文件中应用该变量。</li>
<li>const在变量声明中，它指定变量具有 external 链接。
extern必须应用于所有文件中的所有声明。 默认情况下， (全局 const
变量具有内部链接。)</li>
<li>extern "C" 指定函数在别处定义并使用 C 语言调用约定。 extern
"C"修饰符也可能应用于块中的多个函数声明。</li>
<li>在模板声明中， extern 指定模板已在其他位置实例化。 extern
告知编译器它可以重复使用另一个实例化，而不是在当前位置创建新实例。
有关此用法 extern的详细信息，请参阅 显式实例化。</li>
</ul></li>
</ul>
<h2 id="extern的使用"><code>Extern</code>的使用</h2>
<ul>
<li>小案例</li>
<li><code>extern var</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">头文件</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTERN_TEST_H</span></span><br><span class="line"><span class="comment">/// extern 变量与函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> extern_text_var;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// EXTERN_TEST_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">cpp 文件</span><br><span class="line">--- </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> extern_text_var = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">使用导出变量</span><br><span class="line">---</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> extern_text_var;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printExternVar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;current: &quot;</span> &lt;&lt; extern_text_var &lt;&lt; std::endl;</span><br><span class="line">    extern_text_var = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;do update: &quot;</span> &lt;&lt;extern_text_var &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">main.cpp</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;TestExtern.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;KeyWordsExtern.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printExternVar</span>();</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;add result: &quot;</span>&lt;&lt;<span class="built_in">add</span>(<span class="number">10</span>, <span class="number">30</span>)&lt;&lt;std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">输出</span><br><span class="line">---</span><br><span class="line">current: <span class="number">100</span></span><br><span class="line"><span class="keyword">do</span> update: <span class="number">200</span></span><br><span class="line">add result: <span class="number">40</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>key words</tag>
      </tags>
  </entry>
  <entry>
    <title>Bucket Sort and Cardinality sort</title>
    <url>/2021/11/07/Data%20structure/Bucket-Sort/</url>
    <content><![CDATA[<p>
<p>  桶排序算法介绍...</p>
<span id="more"></span>
<h3 id="桶排序">桶排序</h3>
<ul>
<li><code>T(N,M) = O(M+N)</code>,M 个桶的情况
<ul>
<li>N &gt;&gt; M的时候是相对教优秀的算法</li>
<li>M &gt;&gt; N ???</li>
</ul></li>
<li>假设我们有N = 10个整数，N ∈ [0,999],(此时 M =
1000)；我们便不能在线性时间下完成排序。</li>
</ul>
<h3
id="基数排序按照数字的进制排序10">基数排序：按照数字的进制排序（10）</h3>
<ul>
<li>example:</li>
<li>input: 64 8 216 512 27 729 0 1 343 125
<ul>
<li>使用次位优先(Least Significant Digit)</li>
<li>先按照个位数将元素放到对应的桶Pass1</li>
<li>按照十位放到对应的桶中</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 2%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 10%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 10%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">Bucket</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">5</th>
<th>6</th>
<th style="text-align: center;">7</th>
<th style="text-align: center;">8</th>
<th style="text-align: center;">9</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Pass 1(个位)</td>
<td style="text-align: center;"><font color=red>0</font></td>
<td style="text-align: center;"><font color=red>1</font></td>
<td style="text-align: center;">51<font color=red>2</font></td>
<td style="text-align: center;">34<font color=red>3</font></td>
<td style="text-align: center;">6<font color=red>4</font></td>
<td style="text-align: center;">12<font color=red>5</font></td>
<td>21<font color=red>6</font></td>
<td style="text-align: center;">2<font color=red>7</font></td>
<td style="text-align: center;"><font color=red>8</font></td>
<td style="text-align: center;">72<font color=red>9</font></td>
</tr>
<tr class="even">
<td style="text-align: center;">Pass 2(十位)</td>
<td style="text-align: center;">0<br>1<br>8</td>
<td style="text-align: center;">512<br>216</td>
<td style="text-align: center;">125<br>27<br>729</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">343</td>
<td style="text-align: center;"></td>
<td>64<br></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">Pass 3 (百位)</td>
<td style="text-align: center;">0<br/>1<br/>8<br/>27<br/>64</td>
<td style="text-align: center;">125</td>
<td style="text-align: center;">216</td>
<td style="text-align: center;">343</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">512</td>
<td></td>
<td style="text-align: center;">729</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table>
<ul>
<li>最终的顺序，分别从每个桶中顺序读取即可。</li>
</ul>
<h4 id="时间复杂度-t-opnb">时间复杂度： <code>T= O(P(N+B))</code></h4>
<ul>
<li>较好情况：取决于基数-多少个桶 (B &lt;&lt;
N时差不多是一个线性复杂度的算法)</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Multi KeyWord Sort</title>
    <url>/2021/11/07/Data%20structure/Multi-KeyWord-Sort/</url>
    <content><![CDATA[<p>
  多关键字排序...
</p>
<span id="more"></span>
<h3 id="多关键字排序">多关键字排序</h3>
<ul>
<li><p>扑克牌的例子</p></li>
<li><p>一副扑克牌是按照两种顺序排的：</p>
<ul>
<li>K0,花色：梅花 &lt; 方块 &lt; 红桃 &lt; 黑桃</li>
<li>k1，面值: 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10
&lt; J &lt; Q &lt; K &lt; A</li>
</ul></li>
<li><p>主位优先：（Most Significant Digit）</p>
<ul>
<li>先用四个花色建桶，然后使用面值建桶</li>
</ul></li>
</ul>
<h4 id="一个更好的方法">一个更好的方法：</h4>
<ul>
<li><p>依旧使用次位优先：</p>
<ul>
<li><p>先使用面值建桶</p></li>
<li><p>然后按照大小将结果合并，使用花色建桶。</p></li>
<li><p>最终的输出结果便是有序的</p></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>多重继承下的菱形继承</title>
    <url>/2022/08/19/C++/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<p><code>cpp</code>, 中关于继承的一点问题...</p>
<span id="more"></span>
<h2 id="单继承">单继承</h2>
<ul>
<li>只有一父类的时候，称之为单继承</li>
</ul>
<h2 id="多继承">多继承</h2>
<ul>
<li>一个子类有两个及以上的父类，这个时候，称之为多继承</li>
</ul>
<h3 id="菱形继承">菱形继承</h3>
<ul>
<li>多继承下面的特殊状态, 会产生一些问题。
<ul>
<li>当一个类的父类们同时拥有相同的父类的时候，就会发生二义性 <img
src="https://raw.githubusercontent.com/Ranbun/images/main/diamond_inheritance.PNG"
title="菱形继承" alt="菱形继承" /></li>
</ul></li>
</ul>
<h4 id="问题">问题</h4>
<h5 id="二义性">1 二义性</h5>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/cpp/inherit_ambiguos.png"
title="二义性问题" alt="二义性" />
<figcaption aria-hidden="true">二义性</figcaption>
</figure>
<ul>
<li><p>解决访问的二义性相对简单，可以通过添加类的限定从而访问到具体的数据</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Author</span> :<span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Author</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        Student::name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        Teacher::name_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
</ul>
<h5 id="数据冗余">2 数据冗余</h5>
<ul>
<li>从上面的图来看,菱形继承的数据发生了冗余，以及带来数据访问时候的二义性
<ul>
<li>在<code>Author</code>中存在两份<code>Person</code>的数据</li>
</ul></li>
<li>数据冗余的问题在<code>CPP</code>中通过使用虚继承解决</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Person</span>(std::string name,std::string ID = <span class="string">&quot;&quot;</span>)</span><br><span class="line">        :<span class="built_in">name_</span>(name)</span><br><span class="line">        ,<span class="built_in">id_</span>(ID)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Person</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string name_&#123;<span class="string">&quot;name&quot;</span>&#125;;</span><br><span class="line">    std::string birthDay_&#123;<span class="string">&quot;2000.1.1&quot;</span>&#125;;</span><br><span class="line">    std::string id_&#123;<span class="string">&quot;XXXXXXXXXXXXXXXXXX&quot;</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(std::string name_)</span><br><span class="line">        :<span class="built_in">Person</span>(<span class="string">&quot;stu&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Student</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string stuId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Teacher</span>(std::string name_)</span><br><span class="line">        :<span class="built_in">Person</span>(<span class="string">&quot;teacher&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; __FUNCTION__ &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Teacher</span>() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    std::string teacherId_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="虚继承的实现原理">虚继承的实现原理</h2>
<ul>
<li><p><code>virtual base table pointer</code></p></li>
<li><p><code>virtual table</code></p></li>
<li><p>我们基于上面部分分析关于虚继承的实现的原理</p>
<ul>
<li><code>VS</code>的<code>class</code>布局查看工具 <img
src="https://raw.githubusercontent.com/Ranbun/images/main/cpp/vs_Layout_to_class.png" /></li>
<li>上述信息包含:
虚函数表及布局，类的大小，类成员占用大小，成员相较于起始地址的偏移量，字节对其信息</li>
</ul></li>
<li><p>上述布局中我们可以看到,当虚继承发生,就会在虚基类的直接子类中产生一个<code>vbptr</code>指针,这个指针指向一个虚基类表,<code>Author</code>继承自<code>Teacher&amp;Student</code>,同样继承了虚基类指针,同时<code>Author</code>只存在一份<code>Person</code>的数据.</p></li>
<li><p>我们通过虚基类表中记录的偏移(虚基类到当前类),就可以访问到虚基类的数据成员.</p></li>
</ul>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>inherit</tag>
      </tags>
  </entry>
  <entry>
    <title>Heap</title>
    <url>/2021/10/24/Data%20structure/Heap/</url>
    <content><![CDATA[<p>
  <code>Heap</code>数据结构介绍...
</p>
<span id="more"></span>
<h2 id="堆">堆</h2>
<h4
id="优先队列pripority-queue">优先队列(<code>Pripority Queue</code>)</h4>
<ul>
<li>特殊的
"队列",取出元素的顺序是按照元素的优先级大小，而不是进入队列的先后顺序。</li>
<li>使用数组构建：
<ul>
<li>插入：      总是插入数组的尾部<code>T = O(1)</code></li>
<li>删除：      查找到最大的(最小的元素)：<code>T=O(N)</code>
     从数组中删除元素，需要将元素移动位置：<code>T=O(N)</code></li>
</ul></li>
<li>链表构建：
<ul>
<li>插入：      总是插入链表的头部<code>T = O(1)</code></li>
<li>删除：      查找到最大的(最小的元素)：<code>T=O(N)</code>
     删除元素：<code>T=O(1)</code></li>
</ul></li>
<li>有序数组：
<ul>
<li>插入：     找到合适的位置:<code>T = O(N) or O(log2(N))</code>
    移动元素并插入<code>T=O(N)</code></li>
<li>删除：     删除最后一个元素：<code>T=O(1)</code></li>
</ul></li>
<li>有序链表：
<ul>
<li>插入：     找到合适的位置:<code>T = O(N)</code>
    插入<code>T=O(1)</code></li>
<li>删除：     删除最后一个元素(或者首元素)：<code>T=O(1)</code></li>
</ul></li>
</ul>
<h4 id="最大堆---完全二叉树大顶堆">最大堆 - 完全二叉树（大顶堆）</h4>
<ul>
<li>根元素是当前树中最大的</li>
</ul>
<h5 id="堆的创建----创建空堆">1、堆的创建 -- 创建空堆</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> strut HeapStruct * MaxHeap;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">HeadStruct</span>&#123;</span><br><span class="line">    ElementType * Elements;   <span class="comment">// 存储元素的数组 </span></span><br><span class="line">    <span class="type">int</span> Size;                 <span class="comment">// 当前元素个数</span></span><br><span class="line">    <span class="type">int</span> Capacity;             <span class="comment">// 堆的最大容量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建堆</span></span><br><span class="line"><span class="function">MaxHeap <span class="title">create</span><span class="params">(<span class="type">int</span> MaxSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxHeap H = <span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> HeapStruct));</span><br><span class="line">    H-&gt;Elements = <span class="built_in">malloc</span>((MaxSize+<span class="number">1</span>) * <span class="built_in">sizeof</span>(ElementType));</span><br><span class="line">    H-&gt;size = <span class="number">0</span>;</span><br><span class="line">    H-&gt;Capactity = MaxSize;</span><br><span class="line">    H-&gt;Elements[<span class="number">0</span>] = MaxData;  <span class="comment">// O号位置存储的是哨兵 不是个元素 </span></span><br><span class="line">	<span class="keyword">return</span> H;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="堆的插入">2，堆的插入</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(MaxHeap H,ElementType item)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isFull</span>(H))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;最大堆已经满了&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    i = ++H-&gt;Size;  <span class="comment">// i等于 插入元素后的堆中的最后一个元素的下标</span></span><br><span class="line">    <span class="comment">// 交换节点的位置 </span></span><br><span class="line">    <span class="keyword">for</span>(;H-&gt;Elements[i/<span class="number">2</span>] &lt; item; i = i/<span class="number">2</span>) <span class="comment">// 如果I对应的那个插入元素 大于其父节点的数据 交换两个元素的值</span></span><br><span class="line">    &#123;</span><br><span class="line">        H-&gt;Elements[i] = H-&gt;Elements[i/<span class="number">2</span>];  <span class="comment">// 覆盖结果</span></span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;Elements[i] = item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="堆的删除">3、堆的删除</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出根节点</span></span><br><span class="line"><span class="comment">// 将最后一个元素放到根节点(保留树的特性)</span></span><br><span class="line"><span class="comment">// 修改使其具有最大（最小）堆的特性</span></span><br><span class="line"></span><br><span class="line"><span class="function">EleementType <span class="title">deleteMax</span><span class="params">(MaxHeap H)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> parent,child;</span><br><span class="line">    ElementType MaxChild,temp;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsEmpty</span>(H))</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;堆为空&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    MaxItem = H-&gt;Elements[<span class="number">1</span>]; <span class="comment">// 取出根的最大值 </span></span><br><span class="line">    <span class="comment">// 取出堆中最后一个元素， 并将Size - 1</span></span><br><span class="line">    temp = H-&gt;Elements[H-&gt;Size --];</span><br><span class="line">    <span class="comment">// 调整数据的大小关系 </span></span><br><span class="line">    <span class="keyword">for</span>(parent = <span class="number">1</span>; parent*<span class="number">2</span> &lt; H-&gt;Size;parent = child)  <span class="comment">// 是不是存在左孩子 </span></span><br><span class="line">    &#123;</span><br><span class="line">        child = parent * <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 比较左右孩子的大小</span></span><br><span class="line">        <span class="keyword">if</span>((child != H-&gt;Size)) &amp;&amp; (H-&gt;Elements[child] &lt; H-&gt;Elements[child+<span class="number">1</span>]))  <span class="comment">// 当前child不是最后一个元素 </span></span><br><span class="line">        &#123;</span><br><span class="line">            child++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不满足交换条件 - 结束循环</span></span><br><span class="line">        <span class="keyword">if</span>(temp &gt; H-&gt;Elements[child])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 交换元素 </span></span><br><span class="line">            H-&gt;Elements[parent] = H-&gt;Elements[child];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环结束代表找到temp元素的合适安置位置 -- 放到合适的位置即可</span></span><br><span class="line">    H-&gt;Elements[parent] = temp;</span><br><span class="line">    <span class="keyword">return</span> MaxItem;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="最大堆的建立">4、最大堆的建立</h5>
<p>  建立最大堆：将已经存在的N个元素按最大堆的要求存放在一个一维数组中</p>
<p>  1、通过插入操作，将N个元素一个一个的插入到空堆中去：<code>T = O(NlogN)</code></p>
<p>  2、线性时间复杂度下建立最大堆</p>
<p>​   1、将元素安顺序输入，先构建完全二叉树（下标为1开始）</p>
<p>   2、调整元素位置，使其满足最大堆</p>
<p><a href=https://github.com/CuntBoy/Sort_Algorithm/tree/main/heap style="color:red">Heap
C++ 实现  </a></p>
<h4 id="最小堆--完全二叉树小顶堆">最小堆- 完全二叉树（小顶堆）</h4>
<ul>
<li>可以参照最大堆写</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Physical Sort</title>
    <url>/2021/11/07/Data%20structure/Physical-Sort/</url>
    <content><![CDATA[<p>
  物理排序...
</p>
<span id="more"></span>
<h3 id="物理排序">物理排序</h3>
<ul>
<li>我们从上一节的知识开始
<a href="/2021/11/07/Data%20structure/Table-Sort/" title="Table-Sort">表排序</a>，在某些需求下，我们需要实在的交换表中元素的物理地址，不能通过一张额外的table来达到我们的目的。物理排序可以到达我们的要求</li>
<li>排序完成的结果如下，并且这个排序结果必然有若干个相互独立的环组成</li>
</ul>
<table style="width:100%;">
<colgroup>
<col style="width: 1%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 10%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 11%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">A[0]</th>
<th style="text-align: center;">A[1]</th>
<th style="text-align: center;">A[2]</th>
<th style="text-align: center;">A[3]</th>
<th style="text-align: center;">A[4]</th>
<th style="text-align: center;">A[5]</th>
<th style="text-align: center;">A[6]</th>
<th style="text-align: center;">A[7]</th>
<th style="text-align: center;">A[8]</th>
<th style="text-align: center;">A[9]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Key</td>
<td style="text-align: center;">f</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">g</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">h</td>
<td style="text-align: center;">e</td>
<td style="text-align: center;">i</td>
<td style="text-align: center;">u</td>
</tr>
<tr class="even">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">环</td>
<td style="text-align: center;"><font color=red>3</font></td>
<td style="text-align: center;"><font color=red>5</font></td>
<td style="text-align: center;"><font color=yellow>2</font></td>
<td style="text-align: center;"><font color=red>1</font></td>
<td style="text-align: center;"><font color=blue>7</font></td>
<td style="text-align: center;"><font color=red>0</font></td>
<td style="text-align: center;"><font color=blue>4</font></td>
<td style="text-align: center;"><font color=blue>6</font></td>
<td style="text-align: center;"><font color=pink>8</font></td>
<td style="text-align: center;"><font color="#32FF00">9</font></td>
</tr>
</tbody>
</table>
<ul>
<li><p>我们从<code>table[0]= 3</code>
开始,我们从不同的环的任意一个元素开始切入，遍历元素，最后我们都将回到这个元素，这就是环</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// table[0] -&gt; table[3] -&gt; table[1] -&gt; table[0]</span></span><br><span class="line"><span class="comment">// 上述序列构成了一个环</span></span><br></pre></td></tr></table></figure></li>
<li><p>排序，按环处理：</p>
<ul>
<li><p>首先，取一个临时变量<code>temp</code>随机存储，环中的任意一个元素，以A[0]为例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">temp  = f;  <span class="comment">// 此时A[0] 为空 </span></span><br></pre></td></tr></table></figure></li>
<li><p>将table中的元素放到<code>A[0],A[0] = A[table[0]];</code></p></li>
<li><table style="width:100%;">
<colgroup>
<col style="width: 5%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 3%" />
<col style="width: 18%" />
<col style="width: 3%" />
<col style="width: 18%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
<col style="width: 3%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">A[0]</th>
<th style="text-align: center;">A[1]</th>
<th style="text-align: center;">A[2]</th>
<th style="text-align: center;">A[3]</th>
<th style="text-align: center;">A[4]</th>
<th style="text-align: center;">A[5]</th>
<th style="text-align: center;">A[6]</th>
<th style="text-align: center;">A[7]</th>
<th style="text-align: center;">A[8]</th>
<th style="text-align: center;">A[9]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Key</td>
<td style="text-align: center;">f</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">g</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">h</td>
<td style="text-align: center;">e</td>
<td style="text-align: center;">i</td>
<td style="text-align: center;">u</td>
</tr>
<tr class="even">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">环</td>
<td style="text-align: center;"><font color=red>3</font></td>
<td style="text-align: center;"><font color=red>5</font></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><font color=red>1</font></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"><font color=red>0</font></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">new key</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">null</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">new key</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">null</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">d</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">new key</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">d</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">null</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">new key</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">d</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">f</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">3</td>
<td style="text-align: center;"></td>
<td style="text-align: center;">5</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
</tbody>
</table></li>
<li><p>判断环结束：</p>
<ul>
<li><code>table[i] == i</code>，此时环结束</li>
</ul></li>
</ul></li>
<li><p>复杂度分析：</p>
<ul>
<li>最好： 初始的时候都有序</li>
<li>最坏：两本书(a,b)发生交换，需要三个步骤：
<ul>
<li>两本书发生交换：
<ul>
<li>取出一本(a)，temp</li>
<li>a = b;</li>
<li>b = temp;</li>
</ul></li>
<li>存在[N/2]个环，每个环两个元素，需要[3N/2]此移动</li>
</ul></li>
<li><code>T = O(mN)</code>,m是每个元素A的复制时间</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>构造函数私有化</title>
    <url>/2022/08/29/C++/%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%81%E6%9C%89%E5%8C%96/</url>
    <content><![CDATA[<p>在我使用<code>std::make_unique&lt;Typename T&gt;()</code>构建一个我自定义的类的时候，不小心将构造函数写成了私有的，出现了这个问题-<code>cannot access private member declared in class</code>，这完全是由于不仔细造成的...</p>
<span id="more"></span>
<h2 id="cannot-access-private-member-declared-in-class">cannot access
private member declared in class</h2>
<h3 id="可能的错误原因">可能的错误原因:</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestA</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">TestA</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TestA</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestA</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span> / <span class="keyword">protected</span>: </span><br><span class="line">    <span class="built_in">TestA</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">TestA</span>()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>Selection_sort</title>
    <url>/2021/10/25/Data%20structure/Selection-sort/</url>
    <content><![CDATA[<p>
  选择排序...
</p>
<span id="more"></span>
<h2 id="选择排序">选择排序</h2>
<ul>
<li><p>选择排序，每次从无序的数据中选择一个<code>最大的</code>或者是<code>最小的</code>,放到合适的位置。</p></li>
<li><p>代码实现：</p>
<p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里为了使用最大堆-我们倒着排序 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Selection_Sort</span><span class="params">(ElementType A[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = N<span class="number">-1</span>;i &gt;= <span class="number">0</span>；i--)</span><br><span class="line">    &#123;</span><br><span class="line">    	  max_postion = <span class="built_in">scanForMax</span>(A,<span class="number">0</span>,i); <span class="comment">//获取最大元素的下标 </span></span><br><span class="line">          <span class="built_in">swap</span>(&amp;A[i],&amp;A[max_position]);    <span class="comment">// 交换元素    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>scanForMax</code></p>
<ul>
<li>查找当前无序元素中最大的元素，并返回元素的下标
<ul>
<li>常规下，直接对数组元素进行扫描，时间复杂度<code>O(N)</code>,整个算法的时间复杂度<code>T=O(N^2)</code></li>
<li>优化方案：如何快速找到最大值 -- 最大堆or最小堆。</li>
</ul></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Smart pointer 简介</title>
    <url>/2022/08/01/C++/Smartpointer/</url>
    <content><![CDATA[<p>
  智能指针...
</p>
<span id="more"></span>
<h1 id="smart-pointer">Smart Pointer</h1>
<p style="color:red">
  智能指针是行为类似于指针的类对象，但这种对象还有其他功能。
</p>
<ul>
<li>下面我将将会分别介绍几种不同的智能指针</li>
</ul>
<h3 id="auto_ptr"><code>auto_ptr</code></h3>
<ul>
<li>包含在 <code>&lt;memory&gt;</code> 头文件中</li>
<li>在<code>C++98</code>时被引入</li>
<li>已经在<code>C++11</code>是被弃用</li>
<li>在<code>C++17</code>被移除</li>
</ul>
<h4 id="特点">特点</h4>
<ul>
<li><code>auto_ptr</code>
没有使用引用计数，在复制构造函数和赋值构造函数中将对象所有权转移</li>
<li><code>auto_ptr</code>
不能指向数组，因为<code>auto_ptr</code>在析构的时候只是调用<code>delete</code>,而数组应该要调用<code>delete[]</code></li>
<li><code>auto_ptr</code> 不能和标准容器（vector,list,map…)一起使用
<ul>
<li>由于<code>auto_ptr</code>在复制和赋值构造中将转移所有权</li>
</ul></li>
</ul>
<h3 id="unique_ptr"><code>unique_ptr</code></h3>
<ul>
<li>包含在 <code>&lt;memory&gt;</code> 头文件中</li>
<li>在<code>C++11</code>时被引入</li>
<li>用于解决<code>auto_ptr</code>的拷贝问题</li>
</ul>
<h4 id="特点-1">特点</h4>
<ul>
<li>不支持拷贝操作，只能进行所有权的转移</li>
<li><code>std::unique_ptr</code> 通常用于管理对象的生命周期，包括：
通过保证正常退出和异常退出时的删除，为处理具有动态生命周期的对象的类和函数提供异常安全性</li>
<li>对于自定义的类对象，支持提供自定义的删除器</li>
<li>常用于单线程</li>
<li>可以为空</li>
</ul>
<h3 id="shared_ptr"><code>shared_ptr</code></h3>
<ul>
<li>包含在 <code>&lt;memory&gt;</code>头文件中</li>
<li>在<code>C++11</code>时被引入</li>
<li>支持拷贝和复制</li>
</ul>
<h4 id="特点-2">特点</h4>
<ul>
<li>支持拷贝和复制</li>
<li>对于自定义的类对象，支持提供自定义的删除器</li>
<li>常用于多线程</li>
<li>多个对象可以共享所有权</li>
<li>可以为空</li>
</ul>
<h3 id="weak_ptr"><code>weak_ptr</code></h3>
<ul>
<li>包含在 <code>&lt;memory&gt;</code> 头文件中</li>
<li>在<code>C++11</code>时被引入</li>
<li>它是对 <code>std::shared_ptr</code>
管理的对象的非拥有引用,必须将其转换为 <code>std::shared_ptr</code>
才能访问引用的对象</li>
</ul>
<h4 id="特点-3">特点</h4>
<ul>
<li>解决<code>shared_ptr</code>引起的循环引用问题</li>
<li>获取某个<code>shared_ptr</code>指向对象的临时所有权，在<code>shared_ptr</code>对象被销毁是可以延长此对象的生命周期</li>
</ul>
]]></content>
      <categories>
        <category>study</category>
        <category>coding</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>pointer</tag>
      </tags>
  </entry>
  <entry>
    <title>QuickSort</title>
    <url>/2021/10/28/Data%20structure/QuickSort/</url>
    <content><![CDATA[<p>
  快速排序...
</p>
<span id="more"></span>
<h2 id="quick-sort">Quick Sort</h2>
<h4 id="快速排序概述">1、快速排序概述</h4>
<ul>
<li><p>快速排序也是采用分治的思想实现的，首先你有一组无序的数据，然后通过某种方法，取一个这组数据的中间数（M），然后对这组数据进行分组，大于M放到M的右边，小于M放到M的左边。然后通过相同的方法对这两组数分别做相同的处理，直到数据有序。</p></li>
<li><p>伪码实现</p></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(ElementType A[],<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(N &lt; <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ; <span class="comment">//数据有序 不需要排序</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算主元 -- 将数据分组</span></span><br><span class="line">    pivot = &#123;A|A中的一个元素&#125;</span><br><span class="line">    将A（S）分成两个独立的子集&#123;A[] \ pivot&#125;；</span><br><span class="line">    A1 = &#123;a∈S|a &lt; pivot&#125;;</span><br><span class="line">    A2 = &#123;a∈S|a &gt; pivot&#125;;</span><br><span class="line">    <span class="comment">// 递归调用QuickSort</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="选主元">2、选主元</h4>
<ul>
<li><p>选择一个合适的主元是快速排序算法实现的关键，不能草率的取一个数作为主元。</p></li>
<li><p>下面介绍一种主元的选取方法：</p>
<ul>
<li><p>取头，中，尾的中位数</p></li>
<li><p>伪码描述： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Media3</span><span class="params">(ElementType A[],<span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> center = (left + right) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果坐标的比中间的大</span></span><br><span class="line">    <span class="keyword">if</span>(A[left] &gt; A[center])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Swap</span>(&amp;A[left],&amp;A[center]);  <span class="comment">// 交换 左中的值 </span></span><br><span class="line">        <span class="comment">//此后 A[center] &gt; A[left]</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交换后的左 依旧大于右边</span></span><br><span class="line">    <span class="keyword">if</span>(A[left] &gt; A[right])</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">Swap</span>(&amp;A[left],&amp;A[right]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(A[center] &gt; A[right])</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">Swap</span>(&amp;A[center],&amp;A[right]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A[right] &gt; A[center] 此时我们将center的元素放到此位置，可以只考虑 left+1 -- right-2的元素</span></span><br><span class="line">    <span class="built_in">swap</span>(&amp;A[center],&amp;A[right - <span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> A[rigjt <span class="number">-1</span> ];  <span class="comment">// 返回我们得到的主元 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
</ul></li>
</ul>
<h4 id="子集划分">3、子集划分</h4>
<ul>
<li>每次完成子集划分，主元会放到一个在全局中都正确的位置，将不会在改变。</li>
</ul>
<h4 id="算法实现">4、算法实现</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(ElementType A[], <span class="type">int</span> left,<span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Cutoff &lt;= right - left)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 主元</span></span><br><span class="line">        poivt = <span class="built_in">Media3</span>(A,left,right);</span><br><span class="line">        <span class="type">int</span> i = left;        <span class="comment">// i 当前指向第一个元素的位置 </span></span><br><span class="line">        <span class="type">int</span> j = right - <span class="number">1</span>;   <span class="comment">// J 指向主元的位置 </span></span><br><span class="line">        <span class="keyword">for</span>(;;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(A[++i] &lt; poivt)&#123;&#125;</span><br><span class="line">            <span class="keyword">while</span>(A[--j] &gt; poivt)&#123;&#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(&amp;A[i],A[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(&amp;A[i],&amp;A[right - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 递归 </span></span><br><span class="line">        <span class="built_in">QuickSort</span>(A,left,i<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">QuickSort</span>(A,i,right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Insert_selection</span>(A+left,right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Table-Sort</title>
    <url>/2021/11/07/Data%20structure/Table-Sort/</url>
    <content><![CDATA[<p>
  表排序...
</p>
<span id="more"></span>
<h3 id="表排序">表排序</h3>
<ul>
<li>某些场景，移动元素的成本比较大，元素移动的时间是不可以俘忽略的，为了节省时间，我们不得不寻求其他的办法。
<ul>
<li>定义一个指针数组作为"表"（table）</li>
</ul></li>
<li>概述，存在表A，存储的是对应的关键字，每个关键字代表具体的实体，我们根据关键字进行排序，这样省去额外的数据交换的时间。
<ul>
<li>我们定义一个新的部分<code>table</code>记录数组中每个元素的下标</li>
</ul></li>
</ul>
<table>
<colgroup>
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
<col style="width: 9%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">A[0]</th>
<th style="text-align: center;">A[1]</th>
<th style="text-align: center;">A[2]</th>
<th style="text-align: center;">A[3]</th>
<th style="text-align: center;">A[4]</th>
<th style="text-align: center;">A[5]</th>
<th style="text-align: center;">A[6]</th>
<th style="text-align: center;">A[7]</th>
<th style="text-align: center;">A[8]</th>
<th style="text-align: center;">A[9]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Key</td>
<td style="text-align: center;">f</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">g</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">h</td>
<td style="text-align: center;">e</td>
<td style="text-align: center;">i</td>
<td style="text-align: center;">u</td>
</tr>
<tr class="even">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
</tr>
</tbody>
</table>
<ul>
<li><ul>
<li>初始状态下，<code>table[index]</code> 等于A
的<code>index</code></li>
<li>然后我们同通过任意一种排序比较<code>A[table]</code>对应的关键字的大小，从而交换<code>table</code>中的值——排序</li>
</ul></li>
<li><p>排序结果 -- 使用插入排序</p>
<table style="width:100%;">
<colgroup>
<col style="width: 20%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">A[0]</th>
<th style="text-align: center;">A[1]</th>
<th style="text-align: center;">A[2]</th>
<th style="text-align: center;">A[3]</th>
<th style="text-align: center;">A[4]</th>
<th style="text-align: center;">A[5]</th>
<th style="text-align: center;">A[6]</th>
<th style="text-align: center;">A[7]</th>
<th style="text-align: center;">A[8]</th>
<th style="text-align: center;">A[9]</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Key</td>
<td style="text-align: center;">f</td>
<td style="text-align: center;">d</td>
<td style="text-align: center;">c</td>
<td style="text-align: center;">a</td>
<td style="text-align: center;">g</td>
<td style="text-align: center;">b</td>
<td style="text-align: center;">h</td>
<td style="text-align: center;">e</td>
<td style="text-align: center;">i</td>
<td style="text-align: center;">u</td>
</tr>
<tr class="even">
<td style="text-align: center;">table</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">第零次插入</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">第一次插入</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">第二次插入</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">第三次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">第四次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">第五次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">第六次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">第七次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;"></td>
<td style="text-align: center;"></td>
</tr>
<tr class="odd">
<td style="text-align: center;">第八次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;"></td>
</tr>
<tr class="even">
<td style="text-align: center;">第九次插入</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
</tr>
<tr class="odd">
<td style="text-align: center;">table</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">2</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">7</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">4</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">8</td>
<td style="text-align: center;">9</td>
</tr>
</tbody>
</table></li>
<li><p>到此，上述表变得有序：</p></li>
<li><p>正确的输出结果是:</p>
<ul>
<li><code>A[table[0]],A[table[0]]........</code></li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell-Sort</title>
    <url>/2021/10/26/Data%20structure/Shell-Sort/</url>
    <content><![CDATA[<p>
  希尔排序...
</p>
<span id="more"></span>
<h3 id="希尔排序">希尔排序</h3>
<ul>
<li>希尔排序：预先定义一系列间隔(增量序列)DK，按照间隔，进行间隔排序
<ul>
<li><code>DK[i-1]</code>有序后，执行<code>DK[i]</code>的排序后，<code>DK[i-1]</code>依旧是有序的</li>
</ul></li>
</ul>
<h4 id="原始的希尔排序">1、原始的希尔排序</h4>
<ul>
<li><code>DK[i-1] = 取整(N/2),DK[i] = 取整(DK[i-1]/2)</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shell_sort</span><span class="params">(ElementTypes A[], <span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> D;  <span class="comment">// 当前次序的间隔</span></span><br><span class="line">    <span class="type">int</span> P,i;</span><br><span class="line">    ElementType temp;</span><br><span class="line">    <span class="keyword">for</span>(P=N/<span class="number">2</span>;D&gt;<span class="number">0</span>;D/=<span class="number">2</span>) <span class="comment">// 间隔的变换</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入排序 </span></span><br><span class="line">        <span class="keyword">for</span>(P = D; P&lt;N; P++)</span><br><span class="line">        &#123;</span><br><span class="line">        	temp = A[P];  <span class="comment">// 当前要插入的元素 </span></span><br><span class="line">            <span class="keyword">for</span>(i = P; i &gt;= D &amp;&amp; A[i-D] &gt; temp;i -= D)  <span class="comment">// 和已经有序的元素进行比较</span></span><br><span class="line">            <span class="comment">// 前一个元素A[i-D]如果大于temp，temp放置的位置在i-D之前，i-D位置的元素向后移动</span></span><br><span class="line">            &#123;</span><br><span class="line">                A[i] = A[i-D];</span><br><span class="line">            &#125;</span><br><span class="line">            A[i] = temp;  <span class="comment">// temp 放到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>复杂度分析：
当所有大于的增量的序列的数据都是有序的时候，所有的交换操作都会在增量为1的时候执行，这回导致一个不怎么好的结果，时间复杂度会达到<code>O(N^2)</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>简单排序-冒泡&amp;插入</title>
    <url>/2021/10/19/Data%20structure/sort-bubble-insertion/</url>
    <content><![CDATA[<p>
  简单排序算法...
</p>
<span id="more"></span>
<h2 id="简单排序">简单排序:</h2>
<ul>
<li>冒泡排序</li>
<li>插入排序</li>
</ul>
<p>上述两种排序是相对基础的简单排序,通过交换逆序对逐渐使序列有序。</p>
<p>在常规的排序算法中：我们默认的顺序是从小到大</p>
<h4 id="冒泡排序">1、冒泡排序</h4>
<p>  原理：
冒泡排序是一个两重的<code>for</code>循环，外面一层每循环一次就代表有一个元素被放好，第二重循环做的事情是从没有排好序的元素中取出一个，然后依次和后面的元素作比较，将这些元素中最大的一个放到这些无序元素的最后一个元素的位置，标志着这个元素完成排序——变得有序。</p>
<ul>
<li>C++实现 -- 初始版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> * a,<span class="type">int</span> * b)</span>；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_Sort</span><span class="params">(ElementTYpe A[],<span class="type">int</span> N)</span>  <span class="comment">// A是待排序的数据 N代表的是数据的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">  	<span class="keyword">for</span>(p = N - <span class="number">1</span>;p&gt;=<span class="number">0</span>;p--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; p;i++) <span class="comment">// 从无序的数据中抛出最大的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i+<span class="number">1</span>])  <span class="comment">// 比较元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A+i,(A+(i+<span class="number">1</span>))); <span class="comment">// 交换元素 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> * a,<span class="type">int</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a ^= *b;</span><br><span class="line">    *b ^= *a;</span><br><span class="line">    *a ^= *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>优化版本</li>
</ul>
<p>如是在某一次循环中，提前让数组有序，但是在上述的代码中，即使数据有序了，循环依旧会继续执行，我们需要一个标志，来知道数据已经有序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubble_Sort</span><span class="params">(ElementTYpe A[],<span class="type">int</span> N)</span>  <span class="comment">// A是待排序的数据 N代表的是数据的个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>,i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;       <span class="comment">// 标识数组是否有序</span></span><br><span class="line">  	<span class="keyword">for</span>(p = N - <span class="number">1</span>;p&gt;=<span class="number">0</span>;p--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; p;i++) <span class="comment">// 从无序的数据中抛出最大的</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] &gt; A[i+<span class="number">1</span>])  <span class="comment">// 比较元素</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">swap</span>(A+i,(A+(i+<span class="number">1</span>))); <span class="comment">// 交换元素</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)  <span class="comment">// 满足退出条件 结束循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果展示
<ul>
<li>输入与数据：<code>int a[7] = &#123;3,1,2,98,30,8,90&#125;;</code></li>
</ul></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/bubble_sort.png" /></p>
<ul>
<li>复杂度分析 - 优化版本</li>
</ul>
<p>最好的情况：默认传输进来的元素是有序的，我们只需要，经历一次数据的遍历<code>flag</code>变量会触发循环结束，复杂度：</p>
<center>
T = O(N)
</center>
<p>最坏情况：元素逆序，需要遍历比较所有的元素</p>
<center>
T = O(N^2)
</center>
<h4 id="插入排序">2、插入排序</h4>
<p>插入排序：不发生元素的交换，但是会发生元素的移动，每次获取一个元素(P)，将这个P插入到一个有序的序列中，插入的过程是一个比较+覆盖的过程。</p>
<ul>
<li><p>C++实现</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insertion_Sort</span><span class="params">(ElementType A[],<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p,i，tmp;</span><br><span class="line">    <span class="keyword">for</span>(p = <span class="number">1</span>;p &lt; N;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp = A[p];  <span class="comment">// 获取插入的元素 </span></span><br><span class="line">        <span class="keyword">for</span>(i = p;i &gt; <span class="number">0</span> &amp;&amp; A[i - <span class="number">1</span>] &gt; tmp;i--) <span class="comment">// A[i-1]表示的是有序序列中的最大元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[i] = A[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比较结束后，当前 i - 1指向位置的元素是小于 tmp的，所以：</span></span><br><span class="line">        A[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>结果展示</p>
<ul>
<li>输入与数据：<code>int a[7] = &#123;3,1,1,98,30,8,90&#125;;</code></li>
</ul></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/CuntBoy/images/main/blog/sort/insertion_sort.png" /></p>
<ul>
<li><p>复杂度分析：</p>
<p>最好情况，每次进来的元素不需要，比较。直接插入到相应的位置，此时时间复杂度：</p>
<center>
<p>T = O(N)</p>
</center>
<p>最坏情况，数据逆序，每一次的元素都需要遍历所有的有序元素，此时时间复杂度：</p>
<center>
<p>T = O(N^2)</p>
</center></li>
</ul>
<h4 id="补充说明">补充说明：</h4>
<ul>
<li>时间复杂度下界</li>
</ul>
<p>    概念：对于下边<code>i&lt;j</code>如果A[i] &gt;
A[j]，则称<code>(i,j)</code>是一对逆序对<font color=red>逆序对(inversion)</font></p>
<ul>
<li>在上述的排序中，相邻元素的交换其实是消掉逆序对的操作！<font color=red>如果序列基本有序，那么插入排序简单且高效</font></li>
</ul>
<center>
插入排序：T(N,I) = O(N+I)
</center>
<ul>
<li><p>对于N个不同元素组成的序列，平均具有<code>N(N-1)/4</code>个逆序对。</p></li>
<li><p>对于仅以交换相邻元素来排序的算法，其平均时间复杂度为婐<code>Ω(N^2)</code></p></li>
</ul>
<p>基于上面的描述，我们要提高此类算法的效率，必须每次消去的逆序对数大于1。</p>
<h3 id="下面将会介绍希尔排序">下面将会介绍，希尔排序！</h3>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>归并排序</title>
    <url>/2021/10/26/Data%20structure/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>
  归并排序算法介绍...
</p>
<span id="more"></span>
<h2 id="归并排序">归并排序</h2>
<ul>
<li>归并算法，核心机制是分而治之，每次对数据进行拆分，然后合并，每次拆分直到每次排序的元素个数为1，的时候，单个元素必然是有序的，然后合并便可。</li>
</ul>
<h4 id="有序子列的归并---伪代码">1、有序子列的归并 - 伪代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// L 左边的起始位置 R 右边的起始位置 RightEnd 右边的终点位置</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(ElementType A[],ElementType tempA[],<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> RightEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    leftEnd = R - <span class="number">1</span>  <span class="comment">// 左边部分有序元素的结束位置</span></span><br><span class="line">    temp_index = L;  <span class="comment">// 存放结果数组的初始位置</span></span><br><span class="line">    NumElements = RightEnd - L + <span class="number">1</span>;   <span class="comment">// 计算元素的总个数 - 左右两部份紧挨着 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L] &lt; A[R])</span><br><span class="line">        &#123;</span><br><span class="line">            tempA[temp_index++] = A[L++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// A[L] &gt; A[R]</span></span><br><span class="line">        &#123;</span><br><span class="line">            tempA[temp_index++] = A[R++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= LeftEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tempA[temp_index++] = A[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(R &lt;= RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tempA[temp_index++] = A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将有序的元素写回到A中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span>;i &lt; NumElements;i++,RightEnd--)</span><br><span class="line">    &#123;</span><br><span class="line">        A[RightEnd] = tempA[RightEnd];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="归并的实现---递归">2、归并的实现 - 递归</h4>
<ul>
<li>归并算法的实现有不同的方式，相比之下递归的实现方式相对直观，此处是递归实现的伪代码：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Msort</span><span class="params">(ElementType A[],ElementType tempA[],<span class="type">int</span> L,<span class="type">int</span> RightEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> center;  <span class="comment">// 每次将元素对半砍开 </span></span><br><span class="line">    <span class="keyword">if</span>(L &lt; RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        center = (L + RightEnd) / <span class="number">2</span>;          <span class="comment">// 中间位置的元素</span></span><br><span class="line">        <span class="built_in">MSort</span>(A,tempA,L,center);              <span class="comment">//左半部分 </span></span><br><span class="line">        <span class="built_in">MSort</span>(A,tempA,center+<span class="number">1</span>，RightEnd);    <span class="comment">//右半部分 </span></span><br><span class="line">    	<span class="built_in">Merge</span>(A,tempA,L,center+<span class="number">1</span>,RightEnd);   <span class="comment">// 合并两部分 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="归并的实现---非递归">2、归并的实现 - 非递归</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_Sort</span><span class="params">(ElementType A[],<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">1</span>;   <span class="comment">// 最开始 有序子列的长度</span></span><br><span class="line">    ElementType * tempA;   <span class="comment">// 一个辅助交换的和A等大小的空间</span></span><br><span class="line">    tempA = <span class="keyword">new</span> ElementType[N];</span><br><span class="line">    <span class="keyword">if</span>(tempA != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(length &lt; N)  <span class="comment">// 随着有序子列的扩大，最终一定大于等于N</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">Merge_pass</span>(A,tempA,N,length);</span><br><span class="line">            length *= <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">Merge_pass</span>(tempA,A,N,length);</span><br><span class="line">            length *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> [] tempA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;error&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 源元素位置 目标元素位置 元素个数 有序子列的大小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_pass</span><span class="params">(ElementType A,ElementType tempA,<span class="type">int</span> N,<span class="type">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= N - <span class="number">2</span>*length;i += <span class="number">2</span>*length)   <span class="comment">// 2*length 每次合并的元素的个数 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Merge_</span>(A,tempA,i,i+length,i+<span class="number">2</span>*length - <span class="number">1</span>);  <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i+legnth &lt; N)  <span class="comment">// 剩下的元素个数 &gt; length, 表示还可以进行一次合并： 一组的个数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时最后被合并的数据 个数 &lt; 2*length </span></span><br><span class="line">		<span class="built_in">Merge_</span>(A,tempA,i,i+length,N - <span class="number">1</span>);  <span class="comment">// 合并</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 合并最后部分的元素</span></span><br><span class="line">        <span class="keyword">for</span>(j = i; j &lt; N;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            tempA[j] = A[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_</span><span class="params">(ElementType A[],ElementType tempA[],<span class="type">int</span> L,<span class="type">int</span> R,<span class="type">int</span> RightEnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    leftEnd = R - <span class="number">1</span>  <span class="comment">// 左边部分有序元素的结束位置</span></span><br><span class="line">    temp_index = L;  <span class="comment">// 存放结果数组的初始位置</span></span><br><span class="line">    NumElements = RightEnd - L + <span class="number">1</span>;   <span class="comment">// 计算元素的总个数 - 左右两部份紧挨着 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(L &lt;= LeftEnd &amp;&amp; R &lt;= RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(A[L] &lt; A[R])</span><br><span class="line">        &#123;</span><br><span class="line">            tempA[temp_index++] = A[L++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">// A[L] &gt; A[R]</span></span><br><span class="line">        &#123;</span><br><span class="line">            tempA[temp_index++] = A[R++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(L &lt;= LeftEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tempA[temp_index++] = A[L++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(R &lt;= RightEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        tempA[temp_index++] = A[R++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title>AABB与Ray求交</title>
    <url>/2022/09/14/Computer%20Graphics/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</url>
    <content><![CDATA[<p>光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。
<span id="more"></span></p>
<h2 id="aabb与ray求交">AABB与Ray求交</h2>
<ul>
<li>在之前的部分我们说到了关于<code>OBB</code>与<code>Ray</code>求交的计算<a href="./../../08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/">jump</a>,AABB算是比较特殊的<code>OBB</code>,计算<code>OBB</code>与<code>Ray</code>的方法可能不在适用于<code>AABB</code>与射线的求交计算，当然从原理上来说,这依旧是<code>Slabs Method</code>。</li>
</ul>
<h3 id="计算">计算</h3>
<h4 id="前置判断">前置判断</h4>
<ul>
<li>考虑射线起点在盒子里面的情况</li>
<li>考虑射线和盒子某个面平行的时候</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vec3 begin;<span class="comment">// 射线的起点</span></span><br><span class="line">vec3 u;    <span class="comment">// 射线的方向</span></span><br><span class="line">std::array&lt;vec3,3&gt; normals;  <span class="comment">// 面的三个法线</span></span><br><span class="line">vec3 min,max; <span class="comment">// 盒子的边界点</span></span><br><span class="line"><span class="comment">// 计算是否平行</span></span><br><span class="line"><span class="type">float</span> del = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(u[i] &lt; del)  <span class="comment">// 近似为0  向量表示唯一 在这个方向上没有移动表示它和当前轴垂直</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时判断射线与盒子的关系</span></span><br><span class="line">        <span class="comment">// 在盒子内部必然相交</span></span><br><span class="line">        <span class="keyword">if</span>(begin[i] &lt; min[i] || begin[i] &gt; max[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<h4
id="计算每个方向上对应的slab与射线的相交情况">计算每个方向上对应的<code>slab</code>与射线的相交情况</h4>
<ul>
<li><span class="math inline">\(P = P_0 + t \dots \vec{d}\)</span>
<ul>
<li><span class="math inline">\(\vec{d}\)</span> - 射线的方向</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> del = <span class="number">1e-6</span>;</span><br><span class="line">vec3 begin;<span class="comment">// 射线的起点</span></span><br><span class="line">vec3 u;    <span class="comment">// 射线的方向</span></span><br><span class="line">std::array&lt;vec3,3&gt; normals;  <span class="comment">// 面的三个法线</span></span><br><span class="line">vec3 min,max; <span class="comment">// 盒子的边界点</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> tMin = DBL_MIN,tMax = DBL_MAX;  <span class="comment">// 记录最后获取的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> dis = <span class="number">1.0</span> / u[i];</span><br><span class="line">    <span class="type">float</span> t_min;</span><br><span class="line">    <span class="type">float</span> t_max;</span><br><span class="line">    <span class="keyword">if</span>(dis &gt;= del)</span><br><span class="line">    &#123;</span><br><span class="line">        t_max = = (max[i] - begin[i]) * dis;</span><br><span class="line">        t_min = = (min[i] - begin[i]) * dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t_max = = (min[i] - begin[i]) * dis;</span><br><span class="line">        t_min = = (max[i] - begin[i]) * dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t_max &lt; t_min)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(t_max,t_min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMin &gt; t_min)</span><br><span class="line">    &#123;</span><br><span class="line">        tMin = t_min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMax &lt; t_max)</span><br><span class="line">    &#123;</span><br><span class="line">        tMax = t_max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMin &gt; tMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ture;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="判断">判断</h4>
<ul>
<li>返回结果</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>AABB</tag>
        <tag>Intersect</tag>
      </tags>
  </entry>
  <entry>
    <title>IBL</title>
    <url>/2022/09/08/Computer%20Graphics/IBL/</url>
    <content><![CDATA[<p>基于图像的照明<code>Image Based Lighting</code> <span id="more"></span></p>
]]></content>
      <categories>
        <category>rendering</category>
      </categories>
  </entry>
  <entry>
    <title>AABB与Triangle求交</title>
    <url>/2022/09/08/Computer%20Graphics/AABB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/</url>
    <content><![CDATA[<p><code>AABB</code>
与三角形求交，采用分离轴的方式实现的一种比较优质的方法。 <span id="more"></span></p>
<h2 id="预备知识">0. 预备知识</h2>
<h3 id="点到面的距离方程">点到面的距离方程</h3>
<h3 id="面的方程">面的方程</h3>
<ul>
<li>定义平面<code>A</code>的法向 <span
class="math inline">\(\vec{n}\)</span> <code>&#123;a,b,c&#125;</code>,</li>
<li>已知平面行一点<span class="math inline">\(P_0 \lbrace
x_0,y_0,z_0\rbrace\)</span></li>
<li>任意点 <span
class="math inline">\(P\)</span><code>&#123;x,y,z&#125;</code></li>
<li>面方程:
<ul>
<li><span class="math inline">\(\overrightarrow{P - P_0} \cdot \vec{n} =
0\)</span></li>
</ul></li>
</ul>
<h3 id="点到面的距离">点到面的距离</h3>
<h4 id="法向量法">法向量法</h4>
<ul>
<li><span class="math inline">\(\vec{n}\)</span> - 平面的法向量</li>
<li><span class="math inline">\(d\)</span> - 点到平面的距离</li>
<li><span class="math inline">\(P\)</span> - 平面外一点</li>
<li><span class="math inline">\(A\)</span> - 平面上一点</li>
<li>$d = $
<ul>
<li>PA在法向方向上的投影既是点<span
class="math inline">\(P\)</span>到平面的距离</li>
</ul></li>
</ul>
<h3 id="射线的方程">射线的方程</h3>
<ul>
<li>射线方程
<ul>
<li><span class="math inline">\(O\)</span> 为起点， 沿着方向 <span
class="math inline">\(\vec{d}\)</span></li>
<li>射线方向上任意一点<span class="math inline">\(P_0\)</span></li>
<li><span class="math inline">\(P_0 = O + \vec{d}\)</span></li>
</ul></li>
</ul>
<h2 id="三角形与aabb求交">三角形与AABB求交</h2>
<ul>
<li>我们定义一个轴对齐包围盒
<ul>
<li>center <span class="math inline">\(c\)</span>,
<code>AABB</code>的中心点</li>
<li>a half vector <span class="math inline">\(\vec{h}\)</span>,
记录盒子的各个轴的方向与在轴所在方向大小</li>
</ul></li>
<li>一个三角形
<ul>
<li><span class="math inline">\(\Delta u_0u_1u_2\)</span></li>
</ul></li>
</ul>
<p><img id=AABB&Trangle src=https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/AABB_and_trangle_intersect.png></img></p>
<h3 id="第一步">1. 第一步</h3>
<ul>
<li>移动<code>AABB</code>与三角形，使<code>AABB</code>与原点重合</li>
</ul>
<h3 id="计算测试的轴">2. 计算测试的轴</h3>
<ul>
<li>我们将在原点进行基于分离轴的相交测试，需要测试13根轴。</li>
</ul>
<h4 id="aabb的面的法线">2.1 <code>AABB</code>的面的法线</h4>
<ul>
<li><span class="math inline">\(\vec{e_0}(1,0,0)\)</span></li>
<li><span class="math inline">\(\vec{e_1}(0,1,0)\)</span></li>
<li><span class="math inline">\(\vec{e_2}(0,0,1)\)</span></li>
</ul>
<h4 id="三角形delta-u_0u_1u_2的法线">2.2 三角形<span
class="math inline">\(\Delta u_0u_1u_2\)</span>的法线</h4>
<ul>
<li><span class="math inline">\(\vec{n}\)</span></li>
<li><span class="math inline">\(\vec{n} == \vec{f_0} \times
\vec{f_1}\)</span></li>
</ul>
<h4 id="a_ij-e_i-times-f_j">2.3 <span class="math inline">\(a_{ij} = e_i
\times f_j\)</span></h4>
<ul>
<li><span class="math inline">\(i,j \in \left ( 0,1,2 \right
)\)</span></li>
<li><span class="math inline">\(\vec{f_0} = \vec{v_1} -
\vec{v_0}\)</span></li>
<li><span class="math inline">\(\vec{f_1} = \vec{v_2} -
\vec{v_1}\)</span></li>
<li><span class="math inline">\(\vec{f_0} = \vec{v_0} -
\vec{v_2}\)</span></li>
</ul>
<h3 id="分离轴计算">3 分离轴计算</h3>
<ul>
<li><p>一旦找到分离轴算法就会立即停止并且返回一个不相交的结果</p></li>
<li><p>如果通过所有的测试并且没有找到分离轴，那么三角形与<code>AABB box</code>相交</p></li>
<li><p>将三角形的顶点投影到每一个分离轴上，然后计算<code>AABB</code>在分离轴上的范围,<code>AABB</code>被移动到原点，它的投影将会是一个<span
class="math inline">\(\left [ -r,+r\right ]\)</span>对称的</p>
<ul>
<li>如果她们在这个分离轴上重合，那么它们投影后的结果也是重合的</li>
</ul></li>
<li><p>只有当所有的分离轴上的测试都通过的时候才能是相交的。</p></li>
</ul>
<h2 id="code">Code</h2>
<h3 id="define-aabb">define AABB</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AABB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AABB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AABB</span><span class="params">(<span class="type">const</span> glm::vec3 &amp; center,<span class="type">const</span> glm::vec3 &amp; size)</span></span></span><br><span class="line"><span class="function">        : m_center(center)</span></span><br><span class="line"><span class="function">        , m_size(size)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateTransfrom</span><span class="params">(<span class="type">const</span> glm::mat4 &amp; model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_center = glm::<span class="built_in">vec3</span>( model * glm::<span class="built_in">vec4</span>(m_center,<span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_center;</span><br><span class="line">    glm::vec3 m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="define-triangle">define Triangle</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Triangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 注意三角形的顶点顺序为逆时针</span></span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3, <span class="type">const</span> glm::vec3&amp; normal)</span><br><span class="line">        : <span class="built_in">m_p1</span>(p1)</span><br><span class="line">        , <span class="built_in">m_p2</span>(p2)</span><br><span class="line">        , <span class="built_in">m_p3</span>(p3)</span><br><span class="line">        , <span class="built_in">m_normal</span>(glm::<span class="built_in">normalize</span>(normal))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3)</span><br><span class="line">        : <span class="built_in">m_p1</span>(p1)</span><br><span class="line">        , <span class="built_in">m_p2</span>(p2)</span><br><span class="line">        , <span class="built_in">m_p3</span>(p3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 计算三角形的法相</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                p2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          p3           p1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> v1 = p3 - p1;</span><br><span class="line">        <span class="keyword">auto</span> v2 = p2 - p1;</span><br><span class="line">        m_normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(v2, v1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateTransform</span><span class="params">(glm::mat4 &amp; model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_p1 = <span class="built_in">vec3</span>(model * glm::<span class="built_in">vec4</span>(m_p1,<span class="number">1.0</span>));</span><br><span class="line">        m_p2 = <span class="built_in">vec3</span>(model * glm::<span class="built_in">vec4</span>(m_p2,<span class="number">1.0</span>));</span><br><span class="line">        m_p3 = <span class="built_in">vec3</span>(model * glm::<span class="built_in">vec4</span>(m_p3,<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> v1 = m_p3 - m_p1;</span><br><span class="line">        <span class="keyword">auto</span> v2 = m_p2 - m_p1;</span><br><span class="line">        m_normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(v2, v1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_p1;</span><br><span class="line">    glm::vec3 m_p2;</span><br><span class="line">    glm::vec3 m_p3;</span><br><span class="line">    glm::vec3 m_normal;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// done </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IntersectAABBWithTriangle</span><span class="params">(<span class="type">const</span> AABB &amp;aabb, <span class="type">const</span> Triangle &amp;triangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// move AABB ro  origin</span></span><br><span class="line">    <span class="keyword">auto</span> box = aabb;</span><br><span class="line">    <span class="keyword">auto</span> trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0</span>);</span><br><span class="line">    trans = glm::<span class="built_in">translate</span>(trans,- box.m_center);</span><br><span class="line">    box.<span class="built_in">updateTransfrom</span>(trans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tri = triangle;</span><br><span class="line">    tri.<span class="built_in">updateTransform</span>(trans);</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,13&gt; projectAxis;</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,3&gt; aabbAxisVector;</span><br><span class="line">    &#123;</span><br><span class="line">        aabbAxisVector[<span class="number">0</span>] = glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbAxisVector[<span class="number">1</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbAxisVector[<span class="number">2</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,3&gt; triEdgeVector;</span><br><span class="line">    &#123;</span><br><span class="line">        triEdgeVector[<span class="number">0</span>] = tri.m_p2 - tri.m_p1;</span><br><span class="line">        triEdgeVector[<span class="number">1</span>] = tri.m_p3 - tri.m_p2;</span><br><span class="line">        triEdgeVector[<span class="number">2</span>] = tri.m_p1 - tri.m_p3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> triangleNormal = tri.m_normal;</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,3&gt; aabbFaceNormal;</span><br><span class="line">    &#123;</span><br><span class="line">        aabbFaceNormal[<span class="number">0</span>] = glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbFaceNormal[<span class="number">1</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbFaceNormal[<span class="number">2</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个图形边的随机组合的叉积也作为一个分离轴</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; i: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">    &#123;  <span class="comment">/// AABB</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; j: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        &#123; <span class="comment">/// triangle</span></span><br><span class="line">            projectAxis[i*<span class="number">3</span> + j] = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(aabbAxisVector[i], triEdgeVector[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三角形的法线</span></span><br><span class="line">    projectAxis[<span class="number">9</span>] = triangleNormal;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; index: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        projectAxis[<span class="number">10</span> + index] = aabbFaceNormal[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; it: projectAxis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 投影三角形到分离轴上</span></span><br><span class="line">        <span class="keyword">auto</span> p_0 = glm::<span class="built_in">dot</span>(it,tri.m_p1);</span><br><span class="line">        <span class="keyword">auto</span> p_1 = glm::<span class="built_in">dot</span>(it,tri.m_p2);</span><br><span class="line">        <span class="keyword">auto</span> p_2 = glm::<span class="built_in">dot</span>(it,tri.m_p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算AABB的Size</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> half = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span> * aabb.m_size.x,<span class="number">0.5</span> * aabb.m_size.y,<span class="number">0.5</span> * aabb.m_size.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算AABB的投影的结果的范围</span></span><br><span class="line">        <span class="keyword">auto</span> r = half.x * std::<span class="built_in">abs</span>(<span class="built_in">dot</span>(aabbAxisVector[<span class="number">0</span>],it)) +</span><br><span class="line">                half.y * std::<span class="built_in">abs</span>(<span class="built_in">dot</span>(aabbAxisVector[<span class="number">1</span>],it)) +</span><br><span class="line">                half.z * std::<span class="built_in">abs</span>(<span class="built_in">dot</span>(aabbAxisVector[<span class="number">2</span>],it));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算三角形投影结果的范围</span></span><br><span class="line">        <span class="keyword">auto</span> min_p = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(p_0,p_1),p_2);</span><br><span class="line">        <span class="keyword">auto</span> max_p = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(p_0,p_1),p_2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否相交</span></span><br><span class="line">        <span class="keyword">if</span>(min_p &gt; r || max_p &lt; -r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>AABB</tag>
        <tag>Intersect</tag>
      </tags>
  </entry>
  <entry>
    <title>Games202-ShadowMap</title>
    <url>/2021/12/13/Computer%20Graphics/Games202-ShadowMap/</url>
    <content><![CDATA[<p>
  你该如何渲染阴影...
</p>
<span id="more"></span>
<h2 id="shadow-map">Shadow Map</h2>
<ul>
<li>记录一下关于<code>Games202</code>的学习</li>
</ul>
<h4 id="shadow-map-1">shadow map</h4>
<ul>
<li><p>实现：通过比较当前的<code>point</code>,在光源空间的的深度与深度图中记录的深度的大小，决定当前的<code>point</code>是否在阴影中</p></li>
<li><p>如何获取阴影图：假设相机位置在光源的位置，以此渲染一张纹理，最终得到的这个纹理，每个像素只存储了深度信息，如下：</p>
<p><img
src="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/games202depth_map.png" /></p></li>
</ul>
<p>上图来自<code>Games202</code>的课件：</p>
<ul>
<li><p>阴影图<code>shadow map</code>记录了相机在光照位置下的最近最近深度。</p></li>
<li><p>关于计算当前vertex point
是否在阴影中的问题，还需要将顶点变换到光照空间也需要一个PVM矩阵(相机位置在光源位置-<code>lightPVM</code>)，用于将顶点转换到光空间。</p></li>
<li><p>在<code>Games202</code>的作业1中，我们需要使用提供的matrix的接口处理矩阵。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">mat.<span class="title function_">translate</span>() <span class="comment">// 设置矩阵的移动 </span></span><br><span class="line">mat4.<span class="property">scale</span>      <span class="comment">// 设置矩阵的缩放</span></span><br><span class="line"></span><br><span class="line">mat4.<span class="title function_">lookAt</span>(); <span class="comment">// 生成的视图矩阵</span></span><br><span class="line">mat4.<span class="title function_">ortho</span>();  <span class="comment">// 平行投影</span></span><br><span class="line"></span><br><span class="line">mat4.<span class="title function_">multiply</span>(); <span class="comment">// 矩阵的乘法</span></span><br></pre></td></tr></table></figure>
<p><a
href="https://www.icode9.com/content-4-956693.html">gl-matrix文档</a></p></li>
<li><p>深度比较：</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><span class="line"><span class="type">sampler2D</span> shadowMap;   <span class="comment">// 你的深度图</span></span><br><span class="line"><span class="type">mat4</span> lightPVM;         <span class="comment">// 光空间的变换矩阵</span></span><br><span class="line"><span class="type">vec4</span> vertexPosition;   <span class="comment">// 渲染的顶点坐标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1： 将顶点变换到光空间 </span></span><br><span class="line"><span class="type">vec4</span> vertex_light = lightPVM * vertexPosition;</span><br><span class="line"><span class="comment">// 2: 透视除法将顶点变换到NDC坐标</span></span><br><span class="line"><span class="type">vec3</span> ndc_pos = vertex_light.xyz / vertex_light.w;</span><br><span class="line"><span class="comment">// 3: 将深度变到 0-1</span></span><br><span class="line">ndc_pos = ndc_pos * <span class="number">0.5</span> + <span class="number">0.5</span>；</span><br><span class="line"><span class="comment">// 4：获取深度图中记录的深度</span></span><br><span class="line"><span class="comment">// 5: 获取当前点在光空间下的实际深度</span></span><br><span class="line"><span class="comment">// 6: 比较两个深度的大小    </span></span><br><span class="line"><span class="comment">// 7：返回当前点是否在阴影中    </span></span><br></pre></td></tr></table></figure></li>
<li><p>最终效果</p></li>
</ul>
<p><img
src="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/shadow_map_result.png" /></p>
]]></content>
      <categories>
        <category>Computer Graph</category>
      </categories>
      <tags>
        <tag>Games202</tag>
        <tag>Shadow</tag>
      </tags>
  </entry>
  <entry>
    <title>OBB与OBB求交</title>
    <url>/2022/09/08/Computer%20Graphics/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/</url>
    <content><![CDATA[<p>OBB 全称为 Oriented Bound Box，译为有朝向的包围盒。OBB 常与
AABB(Axis-Aligned Bound Box) 对比：AABB 的边与轴平行，而 OBB
的边则与物体的朝向有关。</p>
<span id="more"></span>
<h3 id="obb求交介绍">OBB求交介绍</h3>
<ul>
<li>采用分离轴的方式计算</li>
<li>两个凸包多边形，当且仅当存在一条线，这两个多边形在这条线上的投影不相交，则这两个多边形也不相交.</li>
<li>这条线称为<code>Separating Axis</code>.垂直<code>Separating Axis</code>存在一条<code>Separating Line</code>将两个多边形分开。</li>
</ul>
<h4 id="obb-to-aabb">OBB to AABB</h4>
<ul>
<li>我们采用一个稍微容易理解的方法完成这种计算 -
将<code>OBB</code>转换为<code>AABB</code></li>
<li>然后使用<code>AABB</code>o
求交的计算方式去算<code>OBB</code>的相交</li>
</ul>
<h3 id="aabb的定义"><code>AABB</code>的定义</h3>
<ul>
<li><code>AABB</code>既是<code>Axis-aligned Bounding Box</code></li>
</ul>
<center>
<img src=https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/define_aabb.png></img>
</center>
<ul>
<li>简单由定义两个最大最小点完成定义，一个<code>OBB</code>也可以描述一个<code>AABB</code></li>
</ul>
<h3 id="obb的定义">OBB的定义</h3>
<ul>
<li><code>m_center</code> 中点位置</li>
<li><code>size</code> 盒子的大小(尺寸)</li>
<li><span class="math inline">\(\vec{u},\vec{v},\vec{w}\)</span>,
坐标系的轴向(与面的法相一样)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">OBB</span></span><br><span class="line"><span class="comment">///&lt; 右手系</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">OBB</span>(<span class="type">const</span> vec3 &amp; pos,<span class="type">const</span> vec3 &amp; size)</span><br><span class="line">        : <span class="built_in">m_pos</span>(pos)</span><br><span class="line">        , <span class="built_in">m_size</span>(size)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBB</span>(<span class="type">const</span> vec3&amp; pos, <span class="type">const</span> vec3&amp; size, <span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v, <span class="type">const</span> vec3&amp; w)</span><br><span class="line">        : <span class="built_in">m_pos</span>(pos)</span><br><span class="line">        , <span class="built_in">m_size</span>(size) </span><br><span class="line">        , <span class="built_in">m_u</span>(u)</span><br><span class="line">        , <span class="built_in">m_v</span>(v)</span><br><span class="line">        , <span class="built_in">m_w</span>(w)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 m_pos&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;   <span class="comment">///&lt; pos </span></span><br><span class="line">    vec3 m_size&#123; <span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span> &#125;;  <span class="comment">///&lt; 长宽高 x = 长 y = 宽 z = 高</span></span><br><span class="line">    vec3 m_u&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;     <span class="comment">///&lt; x</span></span><br><span class="line">    vec3 m_v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;     <span class="comment">///&lt; y </span></span><br><span class="line">    vec3 m_w&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;     <span class="comment">///&lt; z </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="aabb求交"><code>AABB</code>求交</h3>
<ul>
<li>根据分离轴定理，对于<code>AABB</code>我们只需要计算最大最小的点在标准的<span
class="math inline">\({\vec{x},\vec{y},\vec{z}}\)</span>轴上的投影是否相交即可，实现起来比较简单</li>
</ul>
<h4 id="code">code</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersectObbWithObb</span><span class="params">(OBB &amp;first, OBB &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fRes  = <span class="built_in">computerOBBIntersecte</span>(first,second);</span><br><span class="line">    <span class="keyword">auto</span> sRes = <span class="built_in">computerOBBIntersecte</span>(second,first);</span><br><span class="line">    <span class="keyword">return</span> (fRes&amp;sRes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">computerOBBIntersecte</span><span class="params">(OBB first, OBB second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// first</span></span><br><span class="line">    first.m_trans = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>),-first.m_center);</span><br><span class="line">    <span class="keyword">auto</span> rotate = glm::<span class="built_in">mat4</span>(glm::<span class="built_in">vec4</span>(first.m_u, <span class="number">0.0</span>), glm::<span class="built_in">vec4</span>(first.m_v, <span class="number">0.0</span>), glm::<span class="built_in">vec4</span>(first.m_w, <span class="number">0.0</span>), glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>));</span><br><span class="line">    rotate = glm::<span class="built_in">transpose</span>(rotate);</span><br><span class="line">    first.m_rotate = rotate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个matrix变换到第一个变换矩阵描述的空间</span></span><br><span class="line">    first.m_center = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_center,<span class="number">1.0</span>);</span><br><span class="line">    first.m_u = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_u,<span class="number">0.0</span>);</span><br><span class="line">    first.m_v = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_v,<span class="number">0.0</span>);</span><br><span class="line">    first.m_w = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_w,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 second 变换到对应的空间中</span></span><br><span class="line">    <span class="keyword">auto</span> trans2Origin = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0</span>),-second.m_center);</span><br><span class="line">    second.m_trans = trans2Origin;</span><br><span class="line">    <span class="keyword">auto</span> transRestore = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0</span>),second.m_center);</span><br><span class="line">    second.m_center = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_center,<span class="number">1.0</span>);</span><br><span class="line">    second.m_u = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_u,<span class="number">0.0</span>);</span><br><span class="line">    second.m_v = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_v,<span class="number">0.0</span>);</span><br><span class="line">    second.m_w = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_w,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// first Obb max &amp; min position</span></span><br><span class="line">    glm::vec3 fMinPos = first.m_center - first.m_size.x/<span class="number">2.0f</span> * first.m_u - first.m_size.y / <span class="number">2.0f</span> * first.m_v - first.m_size.z/<span class="number">2.0f</span> * first.m_w;</span><br><span class="line">    glm::vec3 fMaxPos = first.m_center + first.m_size.x/<span class="number">2.0f</span> * first.m_u + first.m_size.y / <span class="number">2.0f</span> * first.m_v + first.m_size.z/<span class="number">2.0f</span> * first.m_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算second OBB 的最大最小点</span></span><br><span class="line">    std::array&lt;glm::vec3,8&gt; secondPos;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 右手系</span></span><br><span class="line">        <span class="comment">// m_center + vector * size</span></span><br><span class="line">        secondPos[<span class="number">0</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                second.m_v * second.m_size.y * <span class="number">0.5f</span> -  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">1</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">2</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> - second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">3</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">4</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> -  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">5</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">6</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> - second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">7</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 sMinPos&#123;secondPos[<span class="number">0</span>]&#125;;</span><br><span class="line">    glm::vec3 sMaxPos&#123;secondPos[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it : secondPos)</span><br><span class="line">    &#123;</span><br><span class="line">        sMinPos.x = sMinPos.x &gt; it.x? it.x:sMinPos.x;</span><br><span class="line">        sMinPos.y = sMinPos.y &gt; it.y? it.y:sMinPos.y;</span><br><span class="line">        sMinPos.z = sMinPos.z &gt; it.z? it.z:sMinPos.z;</span><br><span class="line"></span><br><span class="line">        sMaxPos.x = sMaxPos.x &lt; it.x? it.x:sMaxPos.x;</span><br><span class="line">        sMaxPos.y = sMaxPos.y &lt; it.y? it.y:sMaxPos.y;</span><br><span class="line">        sMaxPos.z = sMaxPos.z &lt; it.z? it.z:sMaxPos.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算</span></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        (fMinPos.x &gt; sMaxPos.x || sMinPos.x &gt; fMaxPos.x) ||</span><br><span class="line">        (fMinPos.y &gt; sMaxPos.y || sMinPos.y &gt; fMaxPos.y) ||</span><br><span class="line">        (fMinPos.z &gt; sMaxPos.z || sMinPos.z &gt; fMaxPos.z)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当然也可以直接使用其他的方式计算<code>OBB</code>的求交，分离轴使用相对较多，可以直接投影<code>OBB</code>的最大最小的点到由<code>OBB</code>确定的投影轴上,包含15跟轴</li>
<li><code>OBB A</code>的三个轴向,<code>OBB B</code>的三个轴向 6
根。</li>
<li>两个<code>OBB</code>各自轴向的叉积 =&gt; 3*3 = 9。</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Intersect</tag>
        <tag>OBB</tag>
      </tags>
  </entry>
  <entry>
    <title>Normal Matrix</title>
    <url>/2023/01/02/Computer%20Graphics/Normal-Matrix/</url>
    <content><![CDATA[<h2 id="法线矩阵">法线矩阵</h2>
<ul>
<li><p>在渲染管线的处理过程中，顶点处理阶段会通过模型变换将局部坐标变换到世界坐标,在模型变换的过程中，顶点会经过旋转、缩放、平移的过程.</p></li>
<li><p>法线是和方向相关的向量，所以平移对法向这个方向向量是没有意义的，所以我们考虑的是顶点的旋转与缩放对法线的影响，由于法线属于协变矢量(我们将在后面介绍这个概念)的一种，它不能和顶点使用相同的变换矩阵进行变换.</p></li>
<li><p>为了正确的变换法线，我们必须使用一个和顶点变换矩阵不同的矩阵.</p>
<ul>
<li><p>如果矩阵不包含缩放,无疑，它是合适的，可以安全的变换矩阵</p>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_1.png"
title="不包含缩放的变换矩阵" alt="不包含缩放的变换" />
<figcaption aria-hidden="true">不包含缩放的变换</figcaption>
</figure></li>
<li><p>如果矩阵包含均匀的缩放，它仍旧是安全的，依旧可以用来变换法线，唯一需要做的就是，就是变换完成后重新对法线进行归一化.</p>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_2.png"
title="均匀缩放矩阵" alt="均匀缩放" />
<figcaption aria-hidden="true">均匀缩放</figcaption>
</figure></li>
<li><p>如果矩阵包含非均匀的缩放,我们需要一个新的矩阵处理变换后顶点的法相.</p>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_3.png"
title="非均匀缩放矩阵" alt="非均匀缩放" />
<figcaption aria-hidden="true">非均匀缩放</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="非均匀缩放的法线变换">1. 非均匀缩放的法线变换</h3>
<ul>
<li>通常情况下，我们在世界空间计算光照等</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_5.png"
title="Normal Matrix" alt="Normal Matrix" />
<figcaption aria-hidden="true">Normal Matrix</figcaption>
</figure>
<ul>
<li><p>推导：</p></li>
<li><p><span class="math inline">\(\vec{T}\)</span>表示的是<span
class="math inline">\(\Delta_{ABC}\)</span>的切向量，由<span
class="math inline">\(A - C\)</span>计算得到.</p>
<ul>
<li><span class="math inline">\(\vec{N} \bot \vec{T}\)</span></li>
</ul></li>
<li><p><span class="math inline">\(\vec{T&#39;}\)</span>表示的是<span
class="math inline">\(\Delta_{A&#39;B&#39;C&#39;}\)</span>的切向量，由<span
class="math inline">\(A&#39; - C&#39;\)</span>计算得到.</p>
<ul>
<li>使用相同的变换矩阵之后，<span
class="math inline">\(\vec{N&#39;}\cancel{\bot}
\vec{T&#39;}\)</span></li>
</ul></li>
<li><p>我们使用 <span class="math inline">\(M\)</span>表示模型矩阵</p>
<ul>
<li><span class="math inline">\(T = vec4(x,y,z,w)\)</span></li>
</ul>
<p><span class="math inline">\(T \times M = (A - C) \times
M\)</span></p>
<p><span class="math inline">\(T \times M = A \times M - C \times
M\)</span></p>
<p><span class="math inline">\(T&#39; = A&#39; - C&#39;\)</span></p>
<ul>
<li><span class="math inline">\(A&#39; and
C&#39;\)</span>是三角形变换后的顶点，所以<span
class="math inline">\(T&#39;\)</span>仍旧是三角形变换后的切线</li>
</ul></li>
<li><p><span
class="math inline">\(M\)</span>不能用来变换法线，我们只能通过法线<span
class="math inline">\(\vec{N} \cdot \vec{T} =
0\)</span>的性质来完成下面的推导</p>
<ul>
<li>可得<span class="math inline">\(\vec{N&#39;} \cdot
\vec{T&#39;}\)</span></li>
<li>法线与切线垂直</li>
</ul></li>
<li><p>法线是方向向量，平移对此没有意义，所以我们只考虑模型矩阵的左上角<span
class="math inline">\(3\times3\)</span>部分矩阵<span
class="math inline">\(M&#39;\)</span>,并且变换后的法线 <span
class="math inline">\(\vec{N&#39;}\)</span> 满足<span
class="math inline">\(\vec{N&#39;} \cdot \vec{T&#39;} =
0\)</span></p></li>
<li><p>在我们不知道一个合适的法线变换的矩阵的时候不妨设它<span
class="math inline">\(G\)</span></p></li>
<li><p>此处我们不考虑平移</p></li>
</ul>
<h4 id="推导">推导：</h4>
<p>​ <span class="math inline">\(\vec{N&#39;} \cdot \vec{T&#39;} =
(G_{3\times3} \times \vec{N}) \cdot ( M_{3\times3} \times \vec{T} ) =
0\)</span></p>
<p>$ (G_{3} ) ( M_{3} ) = (G_{3} )^T (M_{3} ) $</p>
<p><span
class="math inline">\(\vec{N}^TG_{3\times3}^TM_{3\times3}\vec{T} =
0\)</span></p>
<p><span class="math inline">\(\vec{N}^T \times \vec{T} = \vec{N} \cdot
\vec{T} = 0\)</span></p>
<p><span class="math inline">\(G_{3\times3}^TM_{3\times3} == I\)</span>
-- 单位矩阵</p>
<p><span class="math inline">\(G_{3\times3}^T == I *
M_{3\times3}^{-1}\)</span></p>
<p><span class="math inline">\(G_{3\times3} == I * (M_{3\times3}^{-1})^T
= (M_{3\times3}^{-1})^T\)</span></p>
]]></content>
      <categories>
        <category>Computer Graph</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>math</tag>
      </tags>
  </entry>
  <entry>
    <title>OBB与Ray求交</title>
    <url>/2022/09/08/Computer%20Graphics/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</url>
    <content><![CDATA[<p>光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。
<span id="more"></span></p>
<h2 id="obb与ray求交">OBB与Ray求交</h2>
<ul>
<li>我们在更之前的地方定义了一个<code>OBB</code>,往前翻一番也许就能找到
<ul>
<li><span class="math inline">\(center\)</span> - 盒子的中心点</li>
<li><span class="math inline">\(\vec{u}\)</span> - 盒子的某个法线 <span
class="math inline">\(u\)</span></li>
<li><span class="math inline">\(\vec{v}\)</span> - 盒子的某个法线 <span
class="math inline">\(v\)</span></li>
<li><span class="math inline">\(\vec{w}\)</span> - 盒子的某个法线 <span
class="math inline">\(w\)</span></li>
<li>盒子的尺寸 - <span class="math inline">\(size\left(h_u,h_v,h_w
\right )\)</span></li>
</ul></li>
<li>同样的 我们曾经定义过一条射线
<ul>
<li><span class="math inline">\(Ray \left( P\right ) = O + t \cdot
\vec{u}\)</span></li>
<li><code>Ray(P)</code> 射线上某一点</li>
<li><code>O</code> 射线的起点</li>
<li><code>t</code> 沿着方向<span
class="math inline">\(\vec{u}\)</span>前进的长度</li>
<li><span class="math inline">\(\vec{u}\)</span> 射线的方向向量</li>
</ul></li>
</ul>
<h2 id="slab-method">slab method</h2>
<ul>
<li>在OBB与光线的求交计算中，我们常用的方法是<code>slab method</code>
<ul>
<li>将我们测量的这个盒子分成三组平行的板</li>
<li>分别将光线与对应的板做相交计算，在射线的方向上，有一个进入这一组板的时间<span
class="math inline">\(t^{min}\)</span>，以及一个出板的时间<span
class="math inline">\(t^{max}\)</span></li>
<li>分别计算对于三个面板的<span
class="math inline">\(t^{min}_{i},t^{max}_{i},i \in
\left(u,v,w\right)\)</span></li>
<li>如果射线与盒子相交，那么简单的说这条射线一定有一段时间是处于这三个<span
class="math inline">\(t^{min},t^{max}\)</span>之中的。</li>
</ul></li>
</ul>
<h3 id="计算原理">计算原理</h3>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/Ray_and_Obb_intersect.png"
title="Ray&amp;OBB" alt="intersection" />
<figcaption aria-hidden="true">intersection</figcaption>
</figure>
<ul>
<li><p><span class="math inline">\(P_{min} = P + t_{min} \cdot
\vec{u}\)</span> - <span class="math inline">\(1.0\)</span></p></li>
<li><p><span class="math inline">\(P_{max} = P + t_{max} \cdot
\vec{u}\)</span> - <span class="math inline">\(1.1\)</span></p></li>
<li><p><span class="math inline">\(P_{i} = P + t \cdot \vec{u}\)</span>
- <span class="math inline">\(1.2\)</span></p></li>
<li><p>$(P_{min} - C ) = min $ - <span
class="math inline">\(1.3\)</span></p></li>
<li><p>$(P_{max} - C ) = max $ - <span
class="math inline">\(1.4\)</span></p></li>
<li><p><span class="math inline">\(1.0\)</span>式 &amp; <span
class="math inline">\(1.1\)</span>式 带入 <span
class="math inline">\(1.3\)</span>式 &amp; <span
class="math inline">\(1.4\)</span>式得到： <span class="math display">\[
\left [ \left (P + t_i \cdot \vec{u} \right ) - C \right ] \cdot
\vec{O_n} = O_{Size.j} / 2.0, i \in (min,max),j \in (x,y,z), n \in
(u,v,w)
\]</span> =&gt; 化简得: <span class="math display">\[
t_i = (O_{Size.i} / 2.0 - (C - P) \cdot \vec{O_n}) / (\vec{u} \cdot
\vec{O_n}), i \in (min,max),j \in (x,y,z), n \in (u,v,w)
\]</span></p></li>
</ul>
<h3 id="求交实现">求交实现</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Intersect::IntersectObbWithRay</span><span class="params">(<span class="type">const</span> OBB&amp; obb, Ray &amp; ray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> delta = obb.m_center - ray.m_begin; <span class="comment">// C- P</span></span><br><span class="line">    <span class="type">float</span> t1, t2;    <span class="comment">// 当前面交点在射线上的位置</span></span><br><span class="line">    <span class="type">double</span> minT = DBL_MIN, maxT = DBL_MAX;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> e = glm::<span class="built_in">dot</span>(delta, obb.m_u);</span><br><span class="line">        <span class="type">float</span> f = glm::<span class="built_in">dot</span>(ray.m_dir, obb.m_u);</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>) <span class="comment">// 判断当前面是否和射线平行 - 与法线垂直则会平行</span></span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.x / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.x / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)  <span class="comment">// 交换 我们不知道当前的射线与目前检测的板的法相的方向是什么样的关系</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)   <span class="comment">// 未发生相交</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)  <span class="comment">// 小于0表示不再正方向上，盒子在射线的后面</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时盒子与光线平行，我们需要看看盒子和光线的关系，如果光线在盒子内部则相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.x / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.x / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> e = glm::<span class="built_in">dot</span>(delta, obb.m_v);</span><br><span class="line">        <span class="type">float</span> f = glm::<span class="built_in">dot</span>(ray.m_dir, obb.m_v);</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.y / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.y / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.y / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.y / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> e = glm::<span class="built_in">dot</span>(delta, obb.m_w);</span><br><span class="line">        <span class="type">float</span> f = glm::<span class="built_in">dot</span>(ray.m_dir, obb.m_w);</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.z / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.z / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.z / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.z / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Intersect</tag>
        <tag>OBB</tag>
      </tags>
  </entry>
  <entry>
    <title>View/Camera Transformation</title>
    <url>/2022/08/19/Computer%20Graphics/View-Camera-Transformation/</url>
    <content><![CDATA[<p>
  计算机图形学的视图变换过程的解析...
</p>
<span id="more"></span>
<h1 id="视图变换">视图变换</h1>
<ul>
<li>视图变换是将所有世界空间中的点，变换到视图空间下的操作
<ul>
<li>这种变换，我们通过矩阵可以轻易的完成，但是我们首先需要计算一个描述这种变换的矩阵</li>
</ul></li>
<li>在一般的实现中，我们将视图变换的过程抽象出了一个相机的概念
<ul>
<li>本身而言在图形学中是没有相机这个概念的</li>
</ul></li>
</ul>
<h2 id="视图变换-变换过程">视图变换-变换过程</h2>
<ul>
<li>从顶点构建到最终渲染成一张二维的图片，在行业中大家将之类比为拍照的行为
<ul>
<li>模型变换 - 取景的过程</li>
<li><font color=red>视图变换 - 摆放相机的过程</font></li>
<li>......</li>
<li>此处我们只是讨论视图变换的过程</li>
</ul></li>
</ul>
<h3 id="定义一个相机">定义一个相机</h3>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/define_cameracamera.png"
title="define camera" alt="camera" />
<figcaption aria-hidden="true">camera</figcaption>
</figure>
<ul>
<li>对于上述的那个拍照的行为，我们要拍摄这个摆放好的景物，关于相机我们只需要关心三个方面。
<ul>
<li>我们基于<font color=red>右手系</font>考虑下面的这些信息</li>
<li>相机的位置 <span class="math inline">\(e\)</span> -&gt; <span
class="math inline">\(eye\)</span> = $x,y,z,1$</li>
<li>相机的看的方向，既相机的拍摄方向 <span
class="math inline">\(\vec{dir}\)</span> - <code>lookAt direction</code>
$x,y,z,0 $</li>
<li>相机的上方向 <span class="math inline">\(\vec{up}\)</span> = <span
class="math inline">\(\lbrace x,y,z,1\rbrace\)</span>
<ul>
<li>大概是手机横屏与竖屏的区别</li>
</ul></li>
</ul></li>
<li>我们获得一个观察方向,一个向上的方向
<ul>
<li>观察方向与向上方向垂直</li>
<li>通过叉积我们可以得到一个向右的方向<span
class="math inline">\(\vec{right}\)</span></li>
</ul></li>
</ul>
<p style="color:red">
  
从拍照的行为来看，相机的观察方向是指向模型摆放的位置，我们保持两个物体的相对位置关系(相机与场景)，相机做了某种变换，模型也跟着做同样的变换。基于这种相对位置的变化，我们约定，将相机永远变换到原点，相机的观察方向永远是
<code> -z </code>方向,以此我们构建一个坐标系
</p>
<p><img id="view_coordinate" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/camera构建坐标系.png"/></p>
<h2 id="计算视图变换矩阵">计算视图变换矩阵</h2>
<p><img id="旋转矩阵构建" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/旋转矩阵的构建.png"/></p>
<ul>
<li>我们将以相机定义的坐标框架通过旋转与平移将之与世界空间的坐标重合
<ul>
<li><span class="math inline">\(\vec{g}\)</span> -&gt; $ $</li>
<li><span class="math inline">\(\vec{t}\)</span> -&gt; $ $</li>
<li><span class="math inline">\(\vec{t} \times \vec{g}\)</span> -&gt;
<span class="math inline">\({\vec{X}}\)</span></li>
<li><font color=red>但是我们要做到上面的事情比较困难，换一种思路，我们做相反的事情</font></li>
</ul></li>
<li>我们将世界空间的坐标通过旋转&amp;平移将之与相机定义的坐标系重合
<ul>
<li><span class="math inline">\(\vec{Y}\)</span> -&gt; <span
class="math inline">\(\vec{t}\)</span></li>
<li><span class="math inline">\(\vec{-Z}\)</span> -&gt; <span
class="math inline">\(\vec{g}\)</span></li>
<li><span class="math inline">\({\vec{X}}\)</span> -&gt; <span
class="math inline">\(\vec{t} \times \vec{g}\)</span></li>
</ul></li>
<li>构建一个旋转矩阵的逆矩阵，然后计算逆矩阵的逆便得到我们想要的矩阵。
<ul>
<li>由于坐标系的三个轴是正交的，我们只需要将矩阵转置就可以得到这个旋转矩阵。</li>
</ul></li>
<li>将旋转矩阵与平移矩阵乘起来，就得到想要的试图变换矩阵</li>
</ul>
<p><img src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/旋转矩阵计算.jpg"/></p>
<p style="color:pink">
<p>   上述过程描述了视图变换的过程与视图矩阵的计算。</p>
</p>
]]></content>
      <categories>
        <category>Computer Graph</category>
      </categories>
      <tags>
        <tag>Base</tag>
      </tags>
  </entry>
  <entry>
    <title>切线空间</title>
    <url>/2023/01/16/Computer%20Graphics/%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="法线贴图">法线贴图</h1>
]]></content>
      <categories>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>texture</tag>
      </tags>
  </entry>
  <entry>
    <title>射线与平面相交</title>
    <url>/2022/10/25/Computer%20Graphics/%E5%B0%84%E7%BA%BF%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<h2 id="计算射线与平面的相交">计算射线与平面的相交</h2>
<ul>
<li>定义平面</li>
<li>定义射线</li>
<li>解方程</li>
</ul>
<h3 id="平面方程">1. 平面方程</h3>
<h4 id="平面方程-1">1.1 平面方程</h4>
<ul>
<li><p><span class="math inline">\(p\)</span>为平面上一点，且 <span
class="math inline">\(p = (x,y,z)\)</span></p></li>
<li><p>标量表示： $ ax + by + cz = d $</p></li>
<li><p>矢量表示： $ p = d$</p>
<ul>
<li><span class="math inline">\(\vec{n} = [a,b,c]\)</span></li>
<li>已知任意平面上一点<span class="math inline">\(p\)</span>即可以求得 $
d $</li>
</ul></li>
<li><p>法线 <span class="math inline">\(\vec{n}\)</span>
决定平面的方向</p></li>
<li><p><span class="math inline">\(d\)</span>
定义平面的位置,从原点到平面的有符号的距离</p>
<ul>
<li>此距离表示沿着法线方向滑动，法线方向上的测量</li>
<li><span class="math inline">\(d &gt;
0\)</span>,原点位于平面背面，反之位于正面</li>
</ul></li>
</ul>
<h4 id="三个点确定一个平面">1.2 三个点确定一个平面</h4>
<ul>
<li>按照不同的坐标表示给出不同顺序的点
<ul>
<li>左手系
<ul>
<li>观察平面的正面，以顺时针给出点的顺序</li>
</ul></li>
<li>右手系
<ul>
<li>观察面的正面，以逆时针给出点的顺序</li>
</ul></li>
</ul></li>
<li>点不能共线</li>
<li>三个点在这个确定的平面上</li>
</ul>
<h3 id="射线与平面求交">2. 射线与平面求交</h3>
<ul>
<li><p>前处理</p>
<ul>
<li>射线与平面是否平行(重合)</li>
</ul></li>
<li><p>射线方程</p></li>
<li><p>平面的表示</p></li>
<li><p>解方程</p></li>
</ul>
<h4 id="射线定义">2.1 射线定义</h4>
<ul>
<li><p>定义射线的起点 <span class="math inline">\(P_0 =
(x,y,z)\)</span></p></li>
<li><p>射线的方向<span class="math inline">\(\vec{u}\)</span></p></li>
<li><p>定义如下: <span class="math inline">\(P = P_0 + t *
\vec{u}\)</span></p>
<ul>
<li><p><span class="math inline">\(P\)</span>为射线上任意一点</p></li>
<li><p><span class="math inline">\(t\)</span>为从起点<span
class="math inline">\(P_0\)</span>沿着方向<span
class="math inline">\(\vec{u}\)</span>前进的距离</p></li>
</ul></li>
</ul>
<h4 id="平面定义">2.2 平面定义</h4>
<ul>
<li><p>已知平面法线与平面上任意向量的点击结果为 <code>0</code></p></li>
<li><p>取平面上任意点<span
class="math inline">\(P_1,P_2\)</span>，平面法线 <span
class="math inline">\(\vec{n}\)</span></p></li>
<li><p>可得：$ = 0 $</p></li>
</ul>
<h4 id="射线与平面的平行计算">2.3 射线与平面的平行计算</h4>
<figure>
<img
src="https://cdn.jsdelivr.net/gh/Ranbun/images/blog/intersection/Ray_intract_plane.png"
title="射线与平面求交" alt="射线与平面求交" />
<figcaption aria-hidden="true">射线与平面求交</figcaption>
</figure>
<ul>
<li>判断射线<span class="math inline">\(Ray_2\)</span>与平面的关系
<ul>
<li>起点 <span class="math inline">\(R_2\)</span></li>
</ul></li>
</ul>
<h5 id="平行判定">平行判定</h5>
<ul>
<li><span class="math inline">\(Ray_2 \cdot \vec{n} = 0\)</span>
<ul>
<li>可知射线<span class="math inline">\(Ray_2\)</span>与平面平行</li>
</ul></li>
</ul>
<h5 id="重合判定">重合判定</h5>
<ul>
<li><p>已知平面一点 <span class="math inline">\(P\)</span></p></li>
<li><p>射线起点<span class="math inline">\(R_2\)</span></p></li>
<li><p>得：</p>
<ul>
<li><span class="math inline">\((P - R_2) \cdot \vec{n} &lt;
0\)</span></li>
<li>可知<span class="math inline">\(R_2\)</span>与点<span
class="math inline">\(P\)</span>不共面</li>
<li>可知射线<span class="math inline">\(Ray_2\)</span>与平面平行</li>
</ul></li>
</ul>
<h4 id="相交计算">2.4 相交计算</h4>
<ul>
<li><p>除去平行与重合的情况，便只剩下相交与不相交</p></li>
<li><p>射线 <span class="math inline">\(P = P_0 + t *
\vec{u}\)</span></p></li>
<li><p>平面 $ = 0 $</p></li>
<li><p>若射线与平面相交，则我们取：</p>
<ul>
<li>$ P_1 = P_0 + t * $</li>
</ul></li>
</ul>
<p>=&gt; 带入到平面方程得: <span class="math display">\[(P_2 - (P_0 +
t*\vec{u})) \cdot \vec{n} = 0\]</span></p>
<p><span class="math display">\[(P_2 - P_0) \cdot \vec{n} - t * \vec{u}
\cdot \vec{n} = 0\]</span></p>
<p><span class="math display">\[ t = \frac{ (P_2 - P_0)\cdot\vec{n}}
{\vec{u}\cdot\vec{n}}\quad \]</span></p>
<ul>
<li>若 <code>t &gt; 0</code>则射线与平面相交，反之不相交</li>
</ul>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>Intersect</tag>
      </tags>
  </entry>
  <entry>
    <title>透视矩阵计算</title>
    <url>/2022/09/08/Computer%20Graphics/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？
关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？
<span id="more"></span></p>
<h2 id="投影变换">投影变换</h2>
<ul>
<li>平行投影</li>
<li>透视投影</li>
</ul>
<center>
<img id="projection" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/projection.png"/>
</center>
<ul>
<li>当我们完成视图变换
<ul>
<li>相机被移动到世界坐标系的原点，同时场景做了同样的相对位移。</li>
<li>相机看向<code>-z</code>方向，我们指定了一个<code>up</code>,通过<code>cross</code>我们分别计算出三个轴向，相当远将世界坐标系做一个旋转操作，变换到<span
class="math inline">\(\vec{right},\vec{up},\vec{look}\)</span> -
相机右方向，上方向，观察方向，<font color=red>场景也要做相同的旋转操作</font></li>
<li>下一步的操作便是投影</li>
</ul></li>
<li>此时，我们的场景变换到了相机描述的坐标系下。</li>
</ul>
<h3 id="平行投影">1. 平行投影</h3>
<ul>
<li>我们最先要做的是定义一个视锥体。
<ul>
<li><span class="math inline">\([left,right]\)</span></li>
<li><span class="math inline">\([bottom,top]\)</span></li>
<li><span class="math inline">\([zNear,ZFar]\)</span></li>
<li><span
class="math inline">\(ortho(left,right,bottom,top,zNear,zFar)\)</span></li>
<li><font color=red>
由于相机朝向<code>-z</code>,实际上说<code>zNear</code>
大于<code>zFar</code></font>.</li>
</ul></li>
<li>如上图<a href="#projection">平行投影与透视投影</a>所示：
平行投影没有近大远小的视觉效果，我们可以简单的丢掉所有顶点的<code>Z</code>值，将他们挤压到一个平面上，就可以得到一个平面的图。这将会丢掉维度信息，且不可逆，将场景变为二维，同是，对于关于<code>XOY</code>平面对称的点相当不友好[<code>-z,z</code>]，所以并不是一个合适的方法。
<ul>
<li>变换矩阵: <span class="math display">\[
  P_0 = \begin{bmatrix}
  1 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 1 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 0 \\
  0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}
  \]</span></li>
</ul></li>
<li>更好的做法是将场景移动到原点，然后做一次缩放，将场景的所有的顶点的坐标变换到<span
class="math inline">\((x,y,z) \in [-1,1]^3\)</span>
<ul>
<li>此时将会生成 <code>z-buffer</code>，三维场景的信息变为<span
class="math inline">\([x,y]^2\)</span>的信息</li>
</ul></li>
</ul>
<center>
<img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/Ortho.png
"/>
</center>
<center>
<img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/ortho_moveandscale.png
"/>
</center>
<ul>
<li>对应矩阵
<ul>
<li><p><code>T matrix</code> <span class="math display">\[
  T =
  \begin{bmatrix}
  1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\
  0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\
  0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\
  0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}
\]</span></p></li>
<li><p><code>S matrix</code> <span class="math display">\[
  S =
  \begin{bmatrix}
  \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\
  0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\
  0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\
  0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}
\]</span></p></li>
<li><p><code>Ortho Matrix</code> <span class="math display">\[
  Ortho =  S \times T =       
  \begin{bmatrix}
      \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\
      0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\
      0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\
      0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}
  \times
  \begin{bmatrix}
      1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\
      0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\
      0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\
      0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix} \\
  = \begin{bmatrix}
          \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp;
-\frac{left+right}{2}\quad  \\
          0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp;
-\frac{top+bottom}{2}\quad  \\
          0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp;
-\frac{zNear+zFar}{2}\quad  \\
          0 &amp; 0 &amp; 0 &amp; 1
  \end{bmatrix}
  \]</span></p></li>
</ul></li>
</ul>
<h3 id="透视投影">2. 透视投影</h3>
<ul>
<li>透视投影变换的过程可以认为是将透视投影定义的视椎体挤压成一个长方体,然后运用平行投影相似的变换(<code>S + T</code>)
<center>
<img id="projection2ortho" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection2ortho.png"/>
</center></li>
</ul>
<h4 id="挤压矩阵计算">2.1. 挤压矩阵计算</h4>
<p><img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection_extrusion_computer.png" />
- 如图<a href="#projection2ortho">projection2ortho</a>,从侧面上看: -
<span class="math inline">\(\vec{g}\)</span> 指向<code>-Z</code>方向 -
<span class="math inline">\(d\)</span> &amp; <span
class="math inline">\(y_s\)</span>构成的三角形在<span
class="math inline">\(e\)</span>的角度为<code>fov</code>的一半 -
压缩是将<span class="math inline">\(y\)</span>压缩到<span
class="math inline">\(y_s\)</span></p>
<h5 id="x_fary_far-to-x_neary_near">2.1.1 <span
class="math inline">\([X_{far},Y_{far}]\)</span> to <span
class="math inline">\([X_{near},Y_{near}]\)</span></h5>
<p><span class="math display">\[
        \begin{pmatrix}
        x \\
        y \\
        z \\
        \end{pmatrix} *  \begin{bmatrix}
        1 &amp; 0 &amp; 0 \\
        0 &amp; n &amp; 0 \\
        0 &amp; 0 &amp; 1 \\
        \end{bmatrix}    = \begin{pmatrix}
        x \\
        y_s \\
        z \\
        \end{pmatrix}
\]</span></p>
<ul>
<li>由三角形相似可以得到: <span
class="math inline">\(\frac{y_s}{y}\quad=\frac{n}{f}\quad\)</span> =&gt;
<span class="math inline">\(y_s = \frac{n}{f}\quad * y\)</span></li>
<li>同理: <span class="math inline">\(\frac{x_s}{x}\quad\)</span>=$ $
=&gt; <span class="math inline">\(x_s = \frac{n}{f}\quad *
x\)</span></li>
</ul>
<h5 id="挤压过程">2.1.2. 挤压过程</h5>
<ul>
<li>将一个点由透视投影的视椎体变换到正交下: <span
class="math display">\[
\begin{pmatrix}
      x \\
      y \\
      z \\
      1
\end{pmatrix} =&gt; \begin{pmatrix}
      \frac{n}{f}\quad*{x} \\
      \frac{n}{f}\quad * y \\
      {???} \\
      1
\end{pmatrix} =&gt; \begin{pmatrix}
      n * x \\
      n * y \\
      {???} \\
      f
\end{pmatrix}
\]</span></li>
</ul>
<p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =
\begin{bmatrix}
            n &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; n &amp; 0 &amp; 0  \\
        c_1 &amp; c_2 &amp; c_3 &amp; c_4  \\
            0 &amp; 0 &amp; 1 &amp; 0
        \end{bmatrix}\]</span></p>
<ul>
<li>考虑当被变换的这个点在近平面中心上: <span
class="math display">\[\begin{pmatrix}
      n * x \\
      n * y \\
      {???} \\
      f
\end{pmatrix}
=&gt;  \begin{pmatrix} \\
      x \\
      y \\
      n \\
      1
  \end{pmatrix} = \begin{pmatrix}
      n*x \\
      n*y \\
      n^2 \\
      n
\end{pmatrix}
\]</span></li>
</ul>
<p><span class="math display">\[
    Mat4^{(4\times4)}_{p-&gt;o}  * \begin{pmatrix}
        x \\
        y \\
        n \\
        1
    \end{pmatrix} = \begin{pmatrix}
        n*x \\
        n*y \\
        n^2 \\
        n
    \end{pmatrix}
\]</span></p>
<p>得到: <span class="math inline">\(c_1 * x + c_2 * y + c_3 * n + c_4 *
1 = n^2\)</span> <br> 得到: <span class="math inline">\(c_3 * n + c_4 =
n^2\)</span></p>
<ul>
<li><p>同理考虑这个点落在远平面的中心: <br> 得到: <span
class="math inline">\(c_3 * f + c_4 = f^2\)</span></p></li>
<li><p>解得:</p>
<ul>
<li><p><span class="math inline">\(c_3\)</span> <span
class="math display">\[
  c_3 = n + f \\
  \]</span></p></li>
<li><p><span class="math inline">\(c_4\)</span> <span
class="math display">\[
  c_4 = -n * f
  \]</span></p></li>
</ul></li>
<li><p><span
class="math inline">\(Mat4^{(4\times4)}_{p-&gt;o}\)</span></p></li>
</ul>
<p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =
\begin{bmatrix}
            n &amp; 0 &amp; 0 &amp; 0 \\
            0 &amp; n &amp; 0 &amp; 0  \\
            0 &amp; 0 &amp; n + f &amp; -n*f  \\
            0 &amp; 0 &amp; 1 &amp; 0
        \end{bmatrix}
\]</span></p>
<h5 id="完整的透视变换矩阵">2.1.3. 完整的透视变换矩阵</h5>
<ul>
<li><span class="math inline">\(Mat^{(4\times4)}_{p-&gt;o} *
Ortho^{4\times4}_{ortho}\)</span> <span class="math display">\[
Mat^{4\times4}_{per} = \begin{bmatrix}
              \frac{2*n}{right - left}\quad &amp; 0 &amp; \frac{right +
left}{right - left}\quad &amp; -\frac{left+right}{2}\quad  \\
              0 &amp; \frac{2*n}{top - bottom}\quad &amp; \frac{top +
bottom}{bottom - top}\quad &amp; 0 \\
              0 &amp; 0 &amp; \frac{zFar + zNear}{zNear - zFar}\quad
&amp; -\frac{2*zFar*zNear}{zFar - zNear}\quad  \\
              0 &amp; 0 &amp; 1 &amp; 0
      \end{bmatrix}
\]</span></li>
</ul>
]]></content>
      <categories>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>projection</tag>
      </tags>
  </entry>
  <entry>
    <title>模型变换-模型矩阵计算</title>
    <url>/2022/09/10/Computer%20Graphics/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[<p>常规的仿射变换(旋转，缩放，平移),
以及一些常用的基本矩阵和这些矩阵的原理<span
class="math inline">\(\dots\)</span></p>
<span id="more"></span>
<h2 id="模型变换">模型变换</h2>
<ul>
<li>仿射变换
<ul>
<li>基本概念：</li>
<li>矩阵的计算</li>
</ul></li>
<li>齐次坐标
<ul>
<li>W分量的意义</li>
</ul></li>
<li>坐标系的变换
<ul>
<li>模型坐标到世界坐标。</li>
</ul></li>
</ul>
<h3 id="齐次坐标">齐次坐标</h3>
<ul>
<li>在开始模型变换的讲解之前，我们首先需要知道，我们的变换的各种操作都是通过矩阵实现的，为了将旋转缩放平移写到一个矩阵中，在计算机图形学中引入了一个叫齐次坐标的东西，给向量<span
class="math inline">\(\vec{a}_{3\times1}\)</span>
扩充一个<code>w</code>维度，<span
class="math inline">\(\vec{a}(x,y,z,w)\)</span>,关于向量我相信大家知道的不少，向量只表示方向与起点与终点没有关系。当然某些时候我们也用来描述一个空间的位置，所以当<code>w</code>分量为<code>0</code>表示的是向量，为<code>1</code>表示的是一个点，注意：
<ul>
<li><span class="math inline">\(\vec{a}(x,y,z,w)\)</span>
<code>==</code> <span class="math inline">\(\vec{a}(w \times x,w \times
y,w \times z,w^2)\)</span></li>
</ul></li>
</ul>
<h3 id="平移">平移</h3>
<ul>
<li>建模师们在建模的时候都是使用模型自己的坐标，规定坐标系的原点在模型这个包围盒的内部，平移要做的操作就是将模型放到世界空间的某个位置。</li>
</ul>
]]></content>
      <categories>
        <category>Computer Graphics</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>translate</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令(上)</title>
    <url>/2022/07/24/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%8A/</url>
    <content><![CDATA[<p>
  Git常用命令...
</p>
<span id="more"></span>
<h1 id="git常用命令">Git常用命令</h1>
<h3 id="install-git"><code>install Git</code></h3>
<ul>
<li>Git -- <a href="https://git-scm.com/">官方网站</a></li>
</ul>
<h3 id="常用命令">常用命令</h3>
<ul>
<li><p>安装完成Git之后的操作 - 指定UserName &amp; Email</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global user.name  &quot;Your Git UserName&quot;</span><br><span class="line">git config --global user.email &quot;Your Email Address&quot;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>一般时候在你安装完成之后需要做一下这个的配置。</li>
</ul></li>
<li><p>生成密钥</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen.exe -t rsa</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>命令提示 <img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/ssh-genkey.png"
alt="Image" /></p></li>
<li><p>然后将你的公钥添加为你所使用的远程管理平台对应SSH Key</p></li>
</ul></li>
<li><p>创建本地版本库</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir repositoryDir  // 创建本地文件夹</span><br><span class="line">cd    repositoryDir  // 进入到文件夹</span><br><span class="line">git   init           // 初始化为本地仓库 创建.git目录</span><br></pre></td></tr></table></figure></p></li>
<li><p>添加文件到本地暂存区&amp;提交文件到本地</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add &quot;fileName&quot;       // 提交具体的文件 </span><br><span class="line">git add .                // 提交所有修改文件</span><br><span class="line">git commit -m  &quot;备注信息&quot; // 提交暂存区文件到本地</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>git commit</code> 命令详解 <img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/git-commit.png"
alt="git commit" /></li>
</ul></li>
<li><p>版本控制</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git log                      //查看提交历史记录，从最近到最远，可以看到3次</span><br><span class="line">git log --pretty=oneline     //加参数，简洁查看</span><br><span class="line">git reflog                   //查看每一次修改历史</span><br><span class="line">cat &quot;fileName&quot;                //查看文件内容 -- linux 命令</span><br><span class="line">git status                   //查看工作区中文件当前状态</span><br><span class="line">git reset --hard HEAD^(HEAD~100)(commit_id)  //回退版本</span><br><span class="line">git checkout -- &quot;fileName&quot;         //丢弃工作区的修改，即撤销修改</span><br><span class="line">git reset HEAD &quot;fileName&quot;          //丢弃暂存区的修改（若已提交，则回退）</span><br></pre></td></tr></table></figure></p></li>
<li><p>删除文件</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm &quot;filename&quot;   // 删除单个文件 </span><br><span class="line">rm -rf *.*      // 强制递归删除所有文件</span><br><span class="line">git rm &quot;filename&quot;  // 直接删除</span><br><span class="line">// 恢复删除的文件</span><br><span class="line">git checkout -- &quot;filename&quot;</span><br></pre></td></tr></table></figure></p></li>
<li><p>推送到远程的相关命令</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;前面设置的Email&quot;     //创建SSH Key 也可以不指定-C与邮件地址</span><br><span class="line">git remote add origin &quot;git的远程仓库地址&quot;  //关联远程仓库-源</span><br><span class="line">git push -u origin main                  //将本地内容推送到远程-第一次强制推送</span><br><span class="line">git push origin main                     //将本地内容推送到远程</span><br><span class="line">git remote -v                            //查看远程源信息</span><br><span class="line">git remote rm origin                     //删除远程源</span><br><span class="line">git clone &quot;远程仓库地址可以是https的也可以是SSH(此时需要配置密钥)&quot;  //克隆远程仓库</span><br><span class="line">git remote                               //查看远程库的信息</span><br><span class="line">git remote -v                            //查看远程库的详细信</span><br></pre></td></tr></table></figure></p></li>
<li><p>分支管理</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 老版本的 git命令 </span><br><span class="line">git checkout -b main        //创建并切换到分支dev</span><br><span class="line">== 如下操作</span><br><span class="line">git branch   feature        //创建分支main</span><br><span class="line">git checkout feature        //切换到分支feature</span><br><span class="line">git checkout branchName origin/main    //拉取远程分支并切换,此时branchName分支对应得远程分支是main</span><br><span class="line">// 版本比较新一定的分支管理命令 </span><br><span class="line">git switch -c feature       //创建分支feature并切换</span><br><span class="line">git switch main             //直接切换到分支main</span><br><span class="line">// -----------------------------------------------------------------------</span><br><span class="line">git branch                  //查看当前分支</span><br><span class="line">git merge  feature          // 合并分支feature到当前分支(记得合并前拉取一下)</span><br><span class="line">git branch -d dev           // 删除dev分支 -d 强制删除</span><br></pre></td></tr></table></figure></p></li>
<li><p>推送到远程</p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git push origin main                               //推送分支到远程</span><br><span class="line">git checkout -b feature origin/feature                     //创建远程origin的dev分支到本地</span><br><span class="line">git pull                                           //拉取远程分支内容</span><br><span class="line">git branch --set-upstream-to=origin/main main        //指定本地与远程dev的链接</span><br><span class="line">// 另一种合并操作，相比merge不会产生一次额外的提交</span><br><span class="line">git rebase                                         //把本地未push的分叉提交历史整理成直线</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令-拉取操作</title>
    <url>/2023/01/09/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E6%8B%89%E5%8F%96%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="git拉取操作"><code>Git</code>拉取操作</h2>
<ul>
<li>第一步，我们应该先克隆一个存储库，拥有一个存储库之后我们才可以进行后面的操作</li>
<li><code>git clone</code> - 克隆远程库</li>
<li><code>cd ...</code></li>
</ul>
<h3 id="查看所有分支">1. 查看所有分支</h3>
<ul>
<li>本地与远程的所有分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a <span class="comment"># 查看本地与远程的所有分支</span></span><br><span class="line">git branch -r <span class="comment"># 查看远程的所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述的两个分支都可以完成查看所有分支的功能</span></span><br></pre></td></tr></table></figure>
<ul>
<li>获取所有的远程分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git fetch --all # 将远程仓库同步到本地,但并不会创建任何可以编辑的分支</span><br></pre></td></tr></table></figure>
<h3 id="创建与远程分支关联的本地分支">2.
创建与远程分支关联的本地分支</h3>
<ul>
<li><p>你将要在本地获得一个分支,这个分支和远程的某个分支关联</p></li>
<li><p>从第一步获取的分支列表中选择一个分支</p></li>
</ul>
<h4 id="使用git默认操作">2.1 使用<code>Git</code>默认操作</h4>
<ul>
<li>创建与远程分支同名的分支</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统自动与远程分支关联</span></span><br><span class="line">git checkout targetBranchName</span><br></pre></td></tr></table></figure>
<h4 id="创建分支指定远程分支">2.2 创建分支指定远程分支</h4>
<ul>
<li>通过<code>git checkout</code>命令参数完成</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -b localBranchName origin/targetBranchName </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用此命令之后,本地分支localBranchName将与远程分支targetBranchName关联</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">localBranchName 可以与targetBranchName同名也可以不同命,为了方便管理,强烈建议使用相同的名称</span></span><br></pre></td></tr></table></figure>
<h4 id="指定跟踪的分支">2.3 指定跟踪的分支</h4>
<ul>
<li><code>track 远程分支</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout --track origin/targetBranchName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建与远程分支关联的分支</span></span><br></pre></td></tr></table></figure>
<h4 id="拉取远程分支到本地">2.4 拉取远程分支到本地</h4>
<ul>
<li>创建与远程分支关联的本地分支</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -t origin/targetBranchName</span><br></pre></td></tr></table></figure>
<h4 id="通过git-fetch">2.5 通过<code>Git Fetch</code></h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br><span class="line">git fetch [&lt;options&gt;] &lt;group&gt;</span><br><span class="line">git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…​]</span><br><span class="line">git fetch --all [&lt;options&gt;]</span><br></pre></td></tr></table></figure>
<ul>
<li><code>options</code>部分建议查阅官方文档</li>
<li><code>repository</code>
<ul>
<li>远程仓库的名字</li>
<li>也可以是 <code>origin</code></li>
</ul></li>
<li>获取远程分支到本地</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch [repo] [targetBranchName]:[localBranchName]   </span><br><span class="line">git fetch origin + origin_test:origin_test <span class="comment">#将远程分支的内容下载到本地并在本地新建分支为origin_test</span></span><br><span class="line">git fetch origin origin_test</span><br><span class="line"><span class="comment"># 此命令执行完后并不会切换到创建的分支,需要手动切换 </span></span><br></pre></td></tr></table></figure>
<h3 id="编辑代码">3. 编辑代码</h3>
<ul>
<li><p><code>do  something</code></p></li>
<li><p>......</p></li>
</ul>
<h3 id="推送代码到远程">4. 推送代码到远程</h3>
<ul>
<li>一般情况是先做一次拉取 -
<code>git pull or git fetch ......</code></li>
<li>然后在进行推送 - <code>git push</code></li>
</ul>
<h4 id="git-pull">4.1 <code>Git Pull</code></h4>
<ul>
<li><code>git pull</code>并不是一个操作,一般是先执行<code>git fetch</code>然后执行一次<code>merge or rebase</code>操作</li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令(下)</title>
    <url>/2023/01/05/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%8B/</url>
    <content><![CDATA[<h2 id="git-常用命令下">Git 常用命令(下)</h2>
<ul>
<li><p>本节主要介绍rebase相关的操作</p></li>
<li><p>我们将以具体的功能来处理你相关的事情</p></li>
</ul>
<h3 id="rebase简介">1. <code>Rebase</code>简介</h3>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/branch_basic.png"
title="branch Basic" alt="branch Basic" />
<figcaption aria-hidden="true">branch Basic</figcaption>
</figure>
<ul>
<li>相信你对于两个分支的<code>merge</code>操作并不陌生,
整合分支最容易的方法是<code>merge</code>命令。
它会把两个分支的最新快照<code>(C3 和 C4)</code>以及二者最近的共同祖先<code>(C2)</code>进行三方合并，合并的结果是生成一个新的快照（并提交）。</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/merge_branch_1.png"
title="Merge branch" alt="Merge Branch" />
<figcaption aria-hidden="true">Merge Branch</figcaption>
</figure>
<ul>
<li><p>你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在
<code>C3</code> 的基础上应用一次。 在 <code>Git</code>
中，这种操作就叫做 <strong>变基<code>（rebase）</code></strong>。
你可以使用 <code>rebase</code>
命令将提交到某一分支上的所有修改都移至另一分支上，就好像"重新播放"一样。</p>
<ul>
<li>在上述的场景中我们做如下操作便可以成功将<code>experiment</code>分支上的修改<code>C4</code>，应用到<code>master</code>分支上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git checkout experiment</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure>
<ul>
<li><p>它的原理是首先找到这两个分支（即当前分支
<code>experiment</code>、变基操作的目标基底分支 <code>master</code>）
的最近共同祖先
<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，<font color=red>提取相应的修改并存为临时文件</font>，
然后将当前分支指向目标基底 <code>C3</code>,
最后以此将之前另存为临时文件的修改依序应用。</p></li>
<li><p>它的过程就像下面描述的那样：</p>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/basic-rebase-3.png"
title="basic rebase 3" alt="Rebase Case" />
<figcaption aria-hidden="true">Rebase Case</figcaption>
</figure></li>
</ul></li>
</ul>
<h3 id="使用rebase合并代码---简单情况">2.
使用<code>rebase</code>合并代码 - 简单情况</h3>
<ul>
<li><p>切换到你要提取的分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git switch &quot;branchName&quot;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>git rebase</code>将当前分支在与目标分支公共父节点之后的提交提取并应用到目标分支</p>
<ul>
<li>当前分支 - <code>experiment</code></li>
<li>目标分支 - <code>master</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure></li>
<li><p>如上图所示，会进行如图上的操作</p>
<ul>
<li>操作完成后<code>experiment</code>指向 - <code>C4'</code>节点</li>
</ul></li>
<li><p>合并<code>experiment</code>的代码到<code>master</code>分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure></li>
<li><p>本此合并完成，同时你可以使用<code>rebase</code>合并之前的提交</p></li>
</ul>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>vector dot product</title>
    <url>/2022/07/28/Math/vector-dot-product/</url>
    <content><![CDATA[<p>
  向量的计算...
</p>
<span id="more"></span>
<h2 id="向量的内积与外积">向量的内积与外积</h2>
<h3 id="点与点的减法">点与点的减法</h3>
<ul>
<li>描述的是起点到终点的运动</li>
</ul>
<h3 id="点p与向量veca的加法">点<span
class="math inline">\({p}\)</span>与向量<span
class="math inline">\(\vec{a}\)</span>的加法</h3>
<ul>
<li>从<span class="math inline">\(P\)</span>出发经过这个向量<span
class="math inline">\(\vec{a}\)</span>代表的运动，到达一个新的点<span
class="math inline">\(P_0\)</span></li>
</ul>
<h3 id="在此处定义两个向量">在此处定义两个向量</h3>
<ul>
<li><span class="math inline">\(\vec{a}\)</span> <span
class="math display">\[  
     \vec{a} = \begin{bmatrix}
        a_1 \\
        a_2 \\
        a_3 \\
      \end{bmatrix}
\]</span></li>
<li><span class="math inline">\(\vec{b}\)</span> <span
class="math display">\[  
    \vec{b} = \begin{bmatrix}
      b_1 \\
      b_2 \\
      b_3 \\
    \end{bmatrix}
\]</span></li>
</ul>
<h3 id="向量点击">向量点击</h3>
<ul>
<li>点击(内积)的公式 <span class="math display">\[\vec{a}\cdot\vec{b} =
|\vec{a}|\times|\vec{b}|\times \cos \theta \]</span> <span
class="math display">\[ \vec{a}\cdot\vec{b} = \sum_{i=1}^{n} \left\{ a_i
* b_i \right\}\]</span></li>
<li>点击的几何意义
<ul>
<li><p>
其中一个向量在另一个向量上的投影且与点击的顺序无关
</p></li>
<li><span class="math inline">\(\vec{a}\cdot\vec{b} &gt; 0\)</span>
方向基本相同，夹角在0°到90°之间</li>
<li><span class="math inline">\(\vec{a}\cdot\vec{b} = 0\)</span>
正交，相互垂直</li>
<li><span class="math inline">\(\vec{a}\cdot\vec{b} &lt; 0\)</span>
方向基本相反，夹角在90°到180°之间</li>
</ul></li>
<li>点击的巧用
<ul>
<li>计算向量的模长的平方 <span class="math display">\[|\vec{a}|^2 =
\vec{a} \cdot \vec{a} \]</span></li>
<li>计算两个向量之间的夹角的<span
class="math inline">\(\cos\theta\)</span> -<img
src="https://raw.githubusercontent.com/Ranbun/images/main/weChat/vector/计算两个向量的夹角.png"
title="计算两个向量之间的夹角" alt="计算两个向量之间的夹角" />
<ul>
<li>两个单位向量的点击等于他们的夹角的<span
class="math inline">\(\cos\theta\)</span>的值</li>
</ul></li>
<li>两个互相垂直的向量的点击总是为<code>0</code> <span
class="math inline">\(\theta = 90^0\)</span> <span
class="math display">\[\vec{a} \cdot \vec{b} = |\vec{a}| \ast |\vec{b}|
\ast \cos\theta = 0 \]</span></li>
<li>一条射线描述的向量[起点 +
方向]点击一个平面的法向可以得到起点到平面的距离<br />
### 向量叉积</li>
</ul></li>
<li>外积公式 <span class="math display">\[
    \vec{a} \times \vec{b} =  
    \begin{bmatrix}
      a_2 * b_3 - b_2 * a_3 \\
      a_3 * b_1 - b_3 * a_1 \\
      a_1 * b_2 - b_1 * a_2 \\
    \end{bmatrix}
\]</span></li>
<li>叉积的几何意义
<ul>
<li>几何表达公式 <span class="math display">\[
  \vec{a} \times \vec{b} = |\vec{a}| * |\vec{b}| * sin(\theta) * \vec{n}
\]</span>
<ul>
<li><span class="math inline">\(\vec{n}\)</span> 表示<span
class="math inline">\(\vec{a}\)</span>, <span
class="math inline">\(\vec{b}\)</span>所构成平面的法向量方向的单位向量</li>
</ul></li>
<li>在二维空间中：叉积得到的向量的模长<span
class="math inline">\(|\vec{a}\times\vec{b}|\)</span>等于这两个向量<span
class="math inline">\(\vec{a},\vec{b}\)</span>组成的平行四边形的面积</li>
</ul></li>
<li>外积的使用
<ul>
<li>外积的模长则为夹角的正弦（始终为正）</li>
</ul></li>
</ul>
<h3 id="扩展知识">扩展知识</h3>
<ul>
<li>扩展 - 1
<ul>
<li>平面上的四个点<span class="math inline">\(P_1\)</span>,<span
class="math inline">\(P_2\)</span>,<span
class="math inline">\(P_3\)</span>,<span
class="math inline">\(P_4\)</span>,分别构成向量 <span
class="math inline">\(\vec{P_1P_2}\)</span>与<span
class="math inline">\(\vec{P_3P_4}\)</span>。如何通过点击计算他们交点的坐标?</li>
<li>下次吧！</li>
</ul></li>
</ul>
]]></content>
      <categories>
        <category>Math</category>
        <category>linear algebra</category>
      </categories>
      <tags>
        <tag>vector</tag>
      </tags>
  </entry>
  <entry>
    <title>反射向量的计算</title>
    <url>/2023/01/09/Math/%E5%8F%8D%E5%B0%84%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title>Dynamic drawing of osg vertex buffer objects</title>
    <url>/2021/11/07/OSG/Dynamic-drawing-of-osg-vertex-buffer-objects/</url>
    <content><![CDATA[<h3
id="dynamic-drawing-of-osg-vertex-buffer-objects"><code>Dynamic drawing of osg vertex buffer objects</code></h3>
<ul>
<li>使用<code>显示列表</code>绘制图形在速度上并没有<code>vertex buffer object</code>那么快，所以在更高的<code>osg</code>的版本中，推荐使用<code>vertex buffer object</code></li>
</ul>
<span id="more"></span>
<ul>
<li><p>在使用<code>vertex buffer object</code>的情况下，动态更新绘制的数据</p></li>
<li><p>代码实现： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先- 创建完成 osg::Geometry</span></span><br><span class="line">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class="keyword">new</span> osg::Geometry;</span><br><span class="line"><span class="comment">// 关闭显示列表 并使用vbo(vertex buffer object)</span></span><br><span class="line">geom-&gt;<span class="built_in">setUseDisplayLists</span>(<span class="literal">false</span>);</span><br><span class="line">geom-&gt;<span class="built_in">setUseVertexBufferObject</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">// 修改几何体的绘制数据的类型 </span></span><br><span class="line">geom-&gt;<span class="built_in">setDataVariance</span>(osg::Object::DataVariance::DYNAMIC);</span><br><span class="line"><span class="comment">//================================================================</span></span><br><span class="line"><span class="comment">// 更新操作 </span></span><br><span class="line"><span class="comment">// 先获取顶点数组 </span></span><br><span class="line"><span class="keyword">auto</span> varray = <span class="built_in">dynamic_cast</span>&lt;osg::Vec3Array&gt;(geom-&gt;<span class="built_in">getVertexArray</span>());</span><br><span class="line"><span class="comment">// 需改顶点数据</span></span><br><span class="line"><span class="comment">// ---------------------你可以想数组中插入顶点-----------------------------------</span></span><br><span class="line"><span class="comment">// 调用 dirty函数，告诉osg::Geometry你修改了顶点</span></span><br><span class="line">varray-&gt;<span class="built_in">dirty</span>();</span><br><span class="line"><span class="comment">// 修改 PrimitiveSet(OpenGL的DrawArray(图元，开始点，绘制个数))</span></span><br><span class="line"><span class="comment">// PrimitiveSet* osg::Geometry::getPrimitiveSet  ( unsigned int  pos ) </span></span><br><span class="line"><span class="keyword">auto</span> pri_set = geom-&gt;<span class="built_in">getPrimitiveSet</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// void  setNumInstances (int n) </span></span><br><span class="line">pri_set-&gt;<span class="built_in">setNumInstances</span>(修改后的顶点个数)；</span><br><span class="line">pri_set-&gt;<span class="built_in">dirty</span>();</span><br><span class="line"><span class="comment">// 更新几何体</span></span><br><span class="line">geom-&gt;<span class="built_in">dirty</span>();</span><br></pre></td></tr></table></figure></p></li>
</ul>
]]></content>
      <categories>
        <category>works</category>
        <category>HJ</category>
        <category>OSG</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>OSG踩坑记-模型共享&amp;模型颜色修改</title>
    <url>/2021/03/20/OSG/OSG%E8%B8%A9%E5%9D%91%E8%AE%B0-%E6%A8%A1%E5%9E%8B%E5%85%B1%E4%BA%AB-%E6%A8%A1%E5%9E%8B%E9%A2%9C%E8%89%B2%E4%BF%AE%E6%94%B9/</url>
    <content><![CDATA[<p>
  <code>OSG</code>模型共享...
</p>
<span id="more"></span>
<h3 id="简单概述">简单概述</h3>
<p>在很多场景中，我们需要将同一个模型绘制到不同的区域并且还需要对模型进行一系列的旋转缩放等操作，同时需要使用不同的颜色，这个时候我们只需要使用一些简单的设置便可以实现这个功能功能。</p>
<h3 id="伪代码">伪代码：</h3>
<h4 id="读入模型">1、读入模型</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无论你是从外部读入模型 还是你自己构建的一个模型都是可以的。</span></span><br><span class="line"><span class="comment">// 使用osg自带读取模型的函数读取模型</span></span><br><span class="line"><span class="comment">// 推荐使用 osg 的智能指针</span></span><br><span class="line"><span class="comment">// 此处使用一个 内嵌的几何体 代替模型 </span></span><br><span class="line"></span><br><span class="line">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class="keyword">new</span> osg::Geometry; </span><br><span class="line"><span class="comment">// osg 的智能指针采用引用计数的方式决定当前对象是否释放</span></span><br></pre></td></tr></table></figure>
<h4
id="计算对模型的旋转缩放平移的操作矩阵">2、计算对模型的旋转、缩放、平移的操作矩阵</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// osg 有专门用户模型操作的类  osg::MatrixTransform </span></span><br><span class="line"><span class="comment">// 创建一个对象 模型操作类中抽象了矩阵的接口 可以当做矩阵操作 本质上是一个节点 </span></span><br><span class="line">osg::ref_ptr&lt;osg::MatrixTransform&gt; trans = <span class="keyword">new</span> osg::MatrixTransform;</span><br><span class="line"><span class="comment">// 对于模型的操作，有PVM矩阵的意思 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建旋转矩阵 </span></span><br><span class="line">osg::Matrix matrix_rotate;</span><br><span class="line"><span class="comment">// 构建旋转，从osg坐标系的沿着Z轴方向转到X轴（都是正方向）  </span></span><br><span class="line">matrix_rotate.<span class="built_in">makeRotate</span>(osg::<span class="built_in">vec3</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>),osg::<span class="built_in">vec3</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>));  <span class="comment">// 参数分别是两个方向向量 第一个参数是当前模型的方向 第二个参数是你需要旋转的方向</span></span><br><span class="line"><span class="comment">// 你也可以直接选择使用</span></span><br><span class="line">osg::Matrix::<span class="built_in">rotate</span>(osg::<span class="built_in">Vec3</span>(),osg::<span class="built_in">Vec3</span>()); <span class="comment">// 输入的参数也可以是四元数  返回值是一个表示旋转的矩阵</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ==============================================================================================</span></span><br><span class="line"><span class="comment">// 也可以直接 设置最终的变换矩阵 </span></span><br><span class="line">trans-&gt;<span class="built_in">setMatrix</span>(matrix_rotate * osg::Martix::<span class="built_in">scale</span>(<span class="number">1.0</span>,<span class="number">1.0</span>,<span class="number">1.0</span>) * osg::<span class="built_in">translate</span>(osg::<span class="built_in">Vec3</span>()));</span><br><span class="line"><span class="comment">// trans 已经存储了 我们对于模型的操作 </span></span><br></pre></td></tr></table></figure>
<h4 id="对trans节点设置材料等属性">3、对trans节点设置材料等属性</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建材质对象</span></span><br><span class="line">osg::Material* mat = <span class="keyword">new</span> osg::<span class="built_in">Material</span>();</span><br><span class="line">mat-&gt;<span class="built_in">setColorMode</span>(osg::Material::ColorMode::DIFFUSE);   <span class="comment">// 设置绘制颜色的模式 </span></span><br><span class="line">mat-&gt;<span class="built_in">setDiffuse</span>(osg::Material::FRONT, osg::<span class="built_in">Vec4</span>());      <span class="comment">// 设置此种模式下的颜色 </span></span><br><span class="line"></span><br><span class="line">trans-&gt;<span class="built_in">getOrCreateStateSet</span>()-&gt;<span class="built_in">setAttribute</span>(mat);        <span class="comment">// 将材质设置给 节点 </span></span><br></pre></td></tr></table></figure>
<h4 id="将对象作为节点添加">4、将对象作为节点添加</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">trans.<span class="built_in">addchild</span>(geom.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<h4
id="将操作节点添加到绘制的根节点或者是其他的叶节点">5、将操作节点添加到绘制的根节点或者是其他的叶节点</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
        <category>OSG</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt Connect</title>
    <url>/2022/07/29/Qt/Qt-Signals-And-Slots/</url>
    <content><![CDATA[<p>
  <code>Qt</code>信号与槽...
</p>
<span id="more"></span>
<h1 id="qt"><code>Qt</code></h1>
<ul>
<li>是非常好的用于开发软件界面的库, 当然我这样说有些狭隘,
<code>Qt</code>能做的事情远不止如此</li>
<li>但本文我只是说一下<code>Qt</code>的信号槽机制</li>
</ul>
<h2 id="qt超级经典的信号与槽机制--signal-slot">1.
<code>Qt</code>超级经典的信号与槽机制- <code>signal</code> &amp;
<code>slot</code></h2>
<ul>
<li><p>示例 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Use_SignalAndSlot</span>:<span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">useSignalsAndSlots</span><span class="params">()</span></span>;</span><br><span class="line">slots: <span class="comment">// (槽函数可以不是slots下的函数)，可以是public or private or protected 下的函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OnuseSignalsAndSlots</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p><code>class</code> 必须是继承自 <code>QObject</code></p></li>
<li><p>要使用<code>Qt</code>的这个机制需要在<code>Class</code>的定义处添加<code>Q_OBJECT</code>的宏定义</p></li>
<li><p>定义信号是必须加上- <code>signals:</code> 前缀,
且信号不需要实现只需要定义，<code>Qt</code>有自己的解析机制</p></li>
</ul>
<h3 id="信号槽的不同写法---官方介绍">1. 信号槽的不同写法 - 官方介绍</h3>
<h4 id="qt4"><code>Qt4</code></h4>
来自官方的文档 - 使用宏包裹 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure>
<p>
  Creates a connection of the given type from the signal in the sender
object to the method in the receiver object. Returns a handle to the
connection that can be used to disconnect it later.<br>   You must use
the <code> SIGNAL() </code> and <code>SLOT()</code> macros when
specifying the signal and the method, for example:
</p>
<ul>
<li><p>上面函数创建一个链接，并将这个链接作为返回值,这个返回值可以用于调用
<code>disconnect</code> 断开链接</p></li>
<li><p>example: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">QScrollBar *scrollBar = <span class="keyword">new</span> QScrollBar;</span><br><span class="line">QObject::<span class="built_in">connect</span>(scrollBar, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span>)),label,  <span class="built_in">SLOT</span>(<span class="built_in">setNum</span>(<span class="type">int</span>)));</span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p><font color=red id="danger">友情提示：请记住这种写法，必须使用<code>SIGNAL</code>&amp;<code>SLOT</code>将对应的信号和槽函数包裹起来，并且这种方法无法检测对应的信号和槽函数是否存在</font></p></li>
<li><p>在创建链接的时候，对应的信号中我们只需要给出参数的类型，不需要写出具体的参数名称:</p>
<p>
<p>  This example ensures that the label always displays the current
scroll bar value. Note that the signal and slots parameters must not
contain any variable names, only the type. E.g. the following would not
work and return false:</p>
</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WRONG</span></span><br><span class="line">QObject::<span class="built_in">connect</span>(scrollBar, <span class="built_in">SIGNAL</span>(<span class="built_in">valueChanged</span>(<span class="type">int</span> value)),label, <span class="built_in">SLOT</span>(<span class="built_in">setNum</span>(<span class="type">int</span> value)));</span><br></pre></td></tr></table></figure></p></li>
<li><p>overloads - 1</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> QMetaMethod &amp;signal, <span class="type">const</span> QObject *receiver, <span class="type">const</span> QMetaMethod &amp;method, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure></p>
<p>
<p>  Creates a connection of the given type from the signal in the
sender object to the method in the receiver object. Returns a handle to
the connection that can be used to disconnect it later.<br>   The
Connection handle will be invalid if it cannot create the connection,
for example, the parameters were invalid. You can check if the
<code>QMetaObject::Connection</code> is valid by casting it to a
bool.<br>   This function works in the same way as <code>connect(const
QObject <em>sender, const char </em>signal, const QObject <em>receiver,
const char </em>method, Qt::ConnectionType type)</code> but it uses
<code>QMetaMethod</code> to specify signal and method.<br> This function
was introduced in Qt 4.8.</p>
</p></li>
<li><p>overloads - 2</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, <span class="type">const</span> <span class="type">char</span> *signal, <span class="type">const</span> <span class="type">char</span> *method, Qt::ConnectionType type = Qt::AutoConnection)</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure></p>
<p>
<p>  This function overloads <code>connect()</code>.<br>   Connects
signal from the sender object to this object's method.<br>   Equivalent
to <code>connect(sender, signal, <font color=red>this</font>, method,
type)</code>.<br>   Every connection you make emits a signal, so
duplicate connections emit two signals. You can break a connection using
<code>disconnect()</code>.<br>   Note: This function is
<font color=#00ff00>thread-safe</font>. <br>
<font color=red>  友情提示： 默认指定this作为接收者</font></p>
</p></li>
</ul>
<h4 id="qt5之后"><code>Qt5</code>之后</h4>
<ul>
<li><p>新的写法 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointerToMemberFunction&gt; <span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, PointerToMemberFunction signal, <span class="type">const</span> QObject *receiver, PointerToMemberFunction method, Qt::ConnectionType type =  Qt::AutoConnection)</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>example</code> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">QLineEdit *lineEdit = <span class="keyword">new</span> QLineEdit;</span><br><span class="line">QObject::<span class="built_in">connect</span>(lineEdit, &amp;QLineEdit::textChanged,label,  &amp;QLabel::setText);</span><br></pre></td></tr></table></figure></p></li>
<li><p>请注意信号和槽函数的参数必须是匹配的</p></li>
<li><p>overloads - 1</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointerToMemberFunction, <span class="keyword">typename</span> Functor&gt; </span><br><span class="line"><span class="function">QMetaObject::Connection <span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender,PointerToMemberFunction signal, Functor functor)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 这是个重载的函数</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Example</li>
</ul>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void someFunction();</span><br><span class="line">QPushButton *button = new QPushButton;</span><br><span class="line">QObject::connect(button, &amp;QPushButton::clicked, someFunction);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Lambda expressions can also be used:</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QByteArray page = ...;</span><br><span class="line">QTcpSocket *socket = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line">socket-&gt;<span class="built_in">connectToHost</span>(<span class="string">&quot;qt-project.org&quot;</span>, <span class="number">80</span>);</span><br><span class="line">QObject::<span class="built_in">connect</span>(socket, &amp;QTcpSocket::connected, [=] () &#123;</span><br><span class="line">        socket-&gt;<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + page + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>
<p>  The connection will automatically disconnect if the sender is
destroyed. However, you should take care that any objects used within
the functor are still alive when the signal is emitted.<br>   Overloaded
functions can be resolved with help of qOverload.<br>  &amp;enspNote:
This function is thread-safe.<br></p>
</p></li>
<li><p>overloads - 2</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> PointerToMemberFunction, <span class="keyword">typename</span> Functor&gt; <span class="function">QMetaObject::Connection </span></span><br><span class="line"><span class="function"><span class="title">QObject::connect</span><span class="params">(<span class="type">const</span> QObject *sender, PointerToMemberFunction signal, <span class="type">const</span> QObject *context, </span></span></span><br><span class="line"><span class="params"><span class="function">                Functor functor, Qt::ConnectionType type = Qt::AutoConnection)</span></span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure></p>
<p>
<p>  This function overloads connect().<br>   Creates a connection of a
given type from signal in sender object to functor to be placed in a
specific event loop of context, and returns a handle to the
connection.<br>   Note: <code>Qt::UniqueConnections</code> do not work
for lambdas, non-member functions and functors; they only apply to
connecting to member functions.<br>   The signal must be a function
declared as a signal in the header. The slot function can be any
function or functor that can be connected to the signal. A function can
be connected to a given signal if the signal has at least as many
argument as the slot. A functor can be connected to a signal if they
have exactly the same number of arguments. There must exist implicit
conversion between the types of the corresponding arguments in the
signal and the slot.</p>
</p>
<ul>
<li>Example:</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">someFunction</span><span class="params">()</span></span>;</span><br><span class="line">QPushButton *button = <span class="keyword">new</span> QPushButton;</span><br><span class="line">QObject::<span class="built_in">connect</span>(button, &amp;QPushButton::clicked, <span class="keyword">this</span>, someFunction, Qt::QueuedConnection);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>Lambda expressions can also be used:</li>
</ul>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QByteArray page = ...;</span><br><span class="line">QTcpSocket *socket = <span class="keyword">new</span> QTcpSocket;</span><br><span class="line">socket-&gt;<span class="built_in">connectToHost</span>(<span class="string">&quot;qt-project.org&quot;</span>, <span class="number">80</span>);</span><br><span class="line">QObject::<span class="built_in">connect</span>(socket, &amp;QTcpSocket::connected, <span class="keyword">this</span>, [=] () &#123;</span><br><span class="line">        socket-&gt;<span class="built_in">write</span>(<span class="string">&quot;GET &quot;</span> + page + <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">    &#125;, Qt::AutoConnection);</span><br></pre></td></tr></table></figure></p>
<p>
<p>  The connection will automatically disconnect if the sender or the
context is destroyed. However, you should take care that any objects
used within the functor are still alive when the signal is emitted.<br>
  Overloaded functions can be resolved with help of qOverload.<br>
  Note: This function is thread-safe.<br>   This function was introduced
in Qt 5.2.</p>
</p></li>
</ul>
<h3 id="信号槽的不同写法---几种一般写法">2. 信号槽的不同写法 -
几种一般写法</h3>
<h5
id="connect的最后一个参数我们暂时使用他的默认认为"><code>connect</code>的最后一个参数，我们暂时使用他的默认认为</h5>
<h4 id="qt4的写法"><code>Qt4的写法</code></h4>
<ul>
<li>宏包裹 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line"><span class="built_in">connect</span>(btn, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), <span class="keyword">this</span>, <span class="built_in">SLOT</span>(<span class="built_in">close</span>()));</span><br></pre></td></tr></table></figure></li>
<li><a href="#danger">注意事项</a></li>
</ul>
<h4 id="qt5后的写法"><code>Qt5</code>后的写法</h4>
<ul>
<li><p>模板匹配</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton; </span><br><span class="line"><span class="built_in">connect</span>(btn, &amp;QPushButton::clicked, <span class="keyword">this</span>, &amp;MainWindow::close);</span><br></pre></td></tr></table></figure></p>
<p>
<p>Qt5后的官方推荐写法，编译的时候信号或槽不存在是无法编译通过的，槽的可以直接写在<code>public
or protected or private</code>下</p>
</p></li>
<li><p>lambda</p>
<div class="sourceCode" id="cb1"><pre
class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">connect</span><span class="op">(</span>btn<span class="op">,</span> <span class="op">&amp;</span><span class="ex">QPushButton::</span>clicked<span class="op">,</span> <span class="op">[&amp;]()</span> <span class="op">&#123;</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">-&gt;</span>close<span class="op">();</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;);</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="fu">connect</span><span class="op">(</span>btn<span class="op">,</span> <span class="op">&amp;</span><span class="ex">QPushButton::</span>clicked<span class="op">,</span> <span class="kw">this</span><span class="op">,</span> <span class="op">[&amp;]()</span> <span class="op">&#123;</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">this</span><span class="op">-&gt;</span>close<span class="op">();</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">&#125;);</span></span></code></pre></div>
<ul>
<li>两种写法本质上是一样的，只是说第一种默认指定接收者为<code>this</code></li>
<li>请保证<code>lambda</code>函数中使用成员都是活跃的，不然将是很糟糕的行为</li>
</ul></li>
</ul>
<h3 id="connect-最后一个参数">3. connect 最后一个参数</h3>
<ul>
<li><p><code>Qt::AutoConnection</code></p>
<ul>
<li>默认使用的参数
<div>
<p>
(Default) If the receiver lives in the thread that emits the signal,
Qt::DirectConnection is used. Otherwise, Qt::QueuedConnection is used.
The connection type is determined when the signal is emitted.
</p>
<p>
如果接收器位于发出信号的线程中，则使用 Qt::DirectConnection。 否则，使用
Qt::QueuedConnection。 连接类型在信号发出时确定
</p>
</div></li>
</ul></li>
<li><p><code>Qt::DirectConnection</code></p>
<div>
<p>
The slot is invoked immediately when the signal is emitted. The slot is
executed in the signalling thread.
</p>
<p>
发出信号时立即调用插槽。 该槽函数在发送者线程中执行。
</p>
</div></li>
<li><p><code>Qt::QueuedConnection</code></p>
<div>
<p>
The slot is invoked when control returns to the event loop of the
receiver's thread. The slot is executed in the receiver's thread.
</p>
<p>
当控制返回到接收者线程的事件循环时调用该槽,会等待当前函数执行结束，重新回到事件循环。
槽函数在接收者的线程中执行.
</p>
</div></li>
<li><p><code>Qt::BlockingQueuedConnection</code></p>
<div>
<p>
Same as Qt::QueuedConnection, except that the signalling thread blocks
until the slot returns. This connection must not be used if the receiver
lives in the signalling thread, or else the application will deadlock.
</p>
<p>
与 Qt::QueuedConnection 相同，只是信号线程阻塞直到槽返回。
如果接收者与发送者在一个线程中，则不得使用此连接，否则应用程序将死锁
</p>
</div></li>
<li><p><code>Qt::UniqueConnection</code></p>
<div>
<p>
This is a flag that can be combined with any one of the above connection
types, using a bitwise OR. When Qt::UniqueConnection is set,
QObject::connect() will fail if the connection already exists (i.e. if
the same signal is already connected to the same slot for the same pair
of objects). This flag was introduced in Qt 4.6.
</p>
<p>
这是一个可以与上述任何一种连接类型结合使用的标志，使用按位或。 当设置了
Qt::UniqueConnection
时，如果连接已经存在（即，如果相同的信号已经连接到同一对对象的同一槽函数），则
QObject::connect() 将失败。 这个标志是在 Qt 4.6 中引入的。
</p>
</div></li>
</ul>
]]></content>
      <categories>
        <category>develop</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>OSG-HUD</title>
    <url>/2021/07/26/OSG/OSG-HUD/</url>
    <content><![CDATA[<p>
  <code>OSG</code>HUD...
</p>
<span id="more"></span>
<h1 id="osg-hud">OSG-HUD</h1>
<ul>
<li><p>
"HUD"在渲染的场景中算是比较常见的存在:
游戏中的小地图(上帝视角)、实时状态、显示鼠标的实时位置、三维视角...
</p></li>
</ul>
<p><b style="color:red">如何创建HUD ？</b></p>
<p>
本质上说，HUD就是一个相机(
在<code>OSG</code>中可以作为节点)，只是不响应鼠标的操作。只需要设置好相关的参数，添加到场景的根节点就行
</p>
<p><b style="color:red">实现要点，如下：</b></p>
<ul>
<li>关闭节点的光照，保证整个视口显示的场景的亮度是一样的。</li>
<li>关闭深度测试</li>
<li>调整渲染的顺序为最后渲染，让<code>HUD</code>显示在整个场景的最前方</li>
<li>设置参考帧为绝对参考帧</li>
<li>设置变换矩阵,不受父节点的影响</li>
<li>设置投影矩阵(平行投影或者透视),设置视口的大小。</li>
</ul>
<h2 id="create-hud">Create HUD</h2>
<h3 id="创建相机节点">1、创建相机节点</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">osg::ref_ptr&lt;osg::Camera&gt; hud_camera = <span class="keyword">new</span> osg::Camera;   <span class="comment">// 创建相机的节点</span></span><br><span class="line">osg::ref_ptr&lt;osg::Geometry&gt; geom = <span class="keyword">new</span> osg::Geometry;      <span class="comment">// 创建绘制的节点(也可以是文字)</span></span><br></pre></td></tr></table></figure>
<h3 id="设置投影矩阵">2、设置投影矩阵</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;<span class="built_in">setProjectionMatrixAsOrtho2D</span>(<span class="number">-3</span>, <span class="number">4</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1.0</span>, <span class="number">100</span>);  <span class="comment">// 2D 也可以 此处设置表示你裁剪的三维空间的实际的能表示的数值的大小</span></span><br></pre></td></tr></table></figure>
<h3 id="设置视口大小viewport">3、设置视口大小(ViewPort)</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void setViewport(osg::Viewport* viewport);</span></span><br><span class="line"><span class="comment">// void setViewport(int x,int y,int width,int height);</span></span><br><span class="line">hud_camera-&gt;<span class="built_in">setviewport</span>();  <span class="comment">// 两种方式都是可以的 </span></span><br></pre></td></tr></table></figure>
<h3 id="设置渲染的顺序">4、设置渲染的顺序</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;<span class="built_in">setRenderOrder</span>(osg::Camera::POST_RENDER);</span><br></pre></td></tr></table></figure>
<h3 id="设置参考帧">5、设置参考帧</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;<span class="built_in">setReferenceFrame</span>(osg::Transform::ABSOLUTE_RF);</span><br></pre></td></tr></table></figure>
<h3 id="设置不受父节点的影响">6、设置不受父节点的影响</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;<span class="built_in">setViewMatrix</span>(osg::Matrix::<span class="built_in">identity</span>());</span><br></pre></td></tr></table></figure>
<h3 id="设置不获取焦点">7、设置不获取焦点</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hud_camera-&gt;<span class="built_in">setAllowEventFocus</span>(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h3 id="设置节点的更新回调">8、设置节点的更新回调</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// void setUpdateCallback(Callback* nc);</span></span><br><span class="line"><span class="comment">// 需要重写一个节点的更新回调 修改节点的视图矩阵 </span></span><br><span class="line"><span class="comment">// 设置相机的三个参数  </span></span><br><span class="line"><span class="comment">// 视点 相机的位置 相机的向上方向</span></span><br><span class="line">hud_camera-&gt;<span class="built_in">setUpdateCallback</span>();</span><br></pre></td></tr></table></figure>
<h2 id="挂载节点">挂载节点</h2>
<h3 id="将前面创建的几何节点挂载到-相机上">1、将前面创建的几何节点挂载到
相机上</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">osg::ref_ptr&lt;osg::Geode&gt; node = <span class="keyword">new</span> osg::Geode;</span><br><span class="line">node-&gt;<span class="built_in">addChild</span>(geom.<span class="built_in">get</span>());</span><br><span class="line">hud_camera-&gt;<span class="built_in">addChild</span>(node.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure>
<h3 id="设置节点的属性">2、设置节点的属性</h3>
<ul>
<li>关闭光照 深度测试 &amp; 打开混溶</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> states = node-&gt;<span class="built_in">getOrCreateStateSet</span>();</span><br><span class="line">states-&gt;<span class="built_in">setMode</span>(GL_LIGHTING, osg::StateAttribute::ON);   <span class="comment">//关闭灯光</span></span><br><span class="line">states-&gt;<span class="built_in">setMode</span>(GL_DEPTH_TEST, osg::StateAttribute::OFF);<span class="comment">//关闭深度测试</span></span><br><span class="line">states-&gt;<span class="built_in">setMode</span>(GL_BLEND, osg::StateAttribute::ON);  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>OSG踩坑记-默认光源</title>
    <url>/2021/04/04/OSG/OSG%E8%B8%A9%E5%9D%91%E8%AE%B0-%E9%BB%98%E8%AE%A4%E5%85%89%E6%BA%90/</url>
    <content><![CDATA[<p>
  <code>OSG</code>默认光源...
</p>
<span id="more"></span>
<h3 id="osg-viewer默认光源">OSG-Viewer默认光源</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">osg::Node-&gt;<span class="built_in">getOrCreateStateSet</span>()-&gt;<span class="built_in">setMode</span>(GL_RESCALE_NORMAL, osg::StateAttribute::ON);    <span class="comment">// 法线随着模型大小变化而变化。</span></span><br><span class="line">osg::Node-&gt;<span class="built_in">getOrCreateStateSet</span>()-&gt;<span class="built_in">setMode</span>(GL_LIGHTING, osg::StateAttribute::OFF | osg::StateAttribute::OVERRIDE); <span class="comment">// 关闭节点光源 并遵从父节点的光照设置</span></span><br></pre></td></tr></table></figure>
<hr />
<h5
id="不指定法向----仍然可以看到-光照效果-但是无法看到明暗变化"><code>不指定法向</code>
-- <font color=red>仍然可以看到 光照效果 但是无法看到明暗变化
</font></h5>
<h3 id="viewer-默认光源的使用">Viewer 默认光源的使用</h3>
<h4 id="设置光照的相关的信息">1、设置光照的相关的信息</h4>
<ul>
<li><p><code>osg::Viewer默认存在缺省光源,但是需要进行部分设置,不然可能与你当前的场景不匹配</code></p></li>
<li><p>你需要设置的信息包括:
ambient、diffuse、specular、光照方向（可以不设置，使用缺省的）、光照位置、光的衰减参数。</p></li>
</ul>
<blockquote>
<p>设置光照 -- <font color=Green>衰减公式</font> <span
class="math display">\[
F = \frac{1}{(k_c + k_l*d + k_q*d^2)}
\]</span></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. 获取缺省的光照</span></span><br><span class="line">osg::Light *light = viewer-&gt;<span class="built_in">getLight</span>(); <span class="comment">// 从当前的查看器 获取光照设置 </span></span><br><span class="line">light-&gt;<span class="built_in">setAmbient</span>(osg::<span class="built_in">Vec4</span>(<span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">0.4</span>, <span class="number">1.0</span>));   <span class="comment">// 环境光   OPENGL的默认值是 osg::Vec3(0.2,0.2,0.2);</span></span><br><span class="line">light-&gt;<span class="built_in">setDiffuse</span>(osg::<span class="built_in">Vec4</span>(<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">1.0</span>));   <span class="comment">// 漫反射   直接来源于光源</span></span><br><span class="line">light-&gt;<span class="built_in">setSpecular</span>(osg::<span class="built_in">Vec4</span>(<span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">0.2</span>, <span class="number">1.0</span>));  <span class="comment">// specular   高光 此处给的很低  </span></span><br><span class="line"><span class="comment">// 由于此处我们使用的是平行光</span></span><br><span class="line"><span class="function">osg::Vec4 <span class="title">lightpos</span><span class="params">(x, y, z, <span class="number">0.0f</span>)</span></span>;   <span class="comment">// 记住: 平行光的位置的最后一个分量必须是 0 </span></span><br><span class="line">light-&gt;<span class="built_in">setPosition</span>(lightpos);        <span class="comment">// 设置光照位置 </span></span><br><span class="line"><span class="comment">// 光照方向设置</span></span><br><span class="line"><span class="comment">// 需要用到高度角和方位角 -- 计算一个你需要方向 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置光的衰减 -- 只设置 常量衰减的话 --   无距离衰减</span></span><br><span class="line">light-&gt;<span class="built_in">setConstantAttenuation</span>(<span class="number">1.0f</span>);</span><br><span class="line">light-&gt;<span class="built_in">setLinearAttenuation</span>(<span class="number">0.0f</span>);</span><br><span class="line">light-&gt;<span class="built_in">setQuadraticAttenuation</span>(<span class="number">0.f</span>);</span><br></pre></td></tr></table></figure>
<p><font color=red> 产生平行光，位置分量的第四分量必须是0 </font></p>
<h4 id="对节点设置好材料属性">2、对节点设置好材料属性</h4>
<ul>
<li>材料的设置是针对你要显示的节点设置的、你可以创建一个材料并设置相关的颜色，这样就可以拥有一个更好的显示效果。</li>
</ul>
]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
        <category>OSG</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Scene ZoomIn &amp; ZoomOut</title>
    <url>/2022/08/03/OpenGL/OpenGL-Scene-ZoomIn-ZoomOut/</url>
    <content><![CDATA[<p>
  <code>QtOpenGL</code>场景缩放...
</p>
<span id="more"></span>
<!-- # `OpenGL Scene ZoomIn & ZoomOut` -->
<center>
<h1>
OpenGL的缩放
</h1>
</center>
<h2 id="about">About</h2>
<h3 id="直接缩放场景">1. 直接缩放场景</h3>
<h4 id="实现思路">1. 实现思路</h4>
<ul>
<li>通过模型矩阵修改场景</li>
</ul>
<h3 id="修改投影矩阵">2. 修改投影矩阵</h3>
<h4 id="实现思路-1">1. 实现思路</h4>
<ul>
<li>获取鼠标滚轮的变化(这个改变是带方向的
向上获取一个正值,向下获取的是一个负值)</li>
<li>将获取的这个值映射到和投影变换参数上</li>
<li>修改投影矩阵</li>
<li>重新绘制,你将获得缩放后的场景</li>
</ul>
<p style="color:red">
在我的实现中采用的是第二种方式
</p>
<h2 id="缩放的实现">缩放的实现</h2>
<h3 id="获取滚轮旋转角度">1. 获取滚轮旋转角度</h3>
<p>
我是用的是<code>Qt</code>的<code>OpenGL</code>,可以直接重写窗口的一些事件，比起使用<code>glfw</code>等方式，比起它们注册回调的方式可能相对方便一些。
</p>
<h4 id="qt的滚轮事件">Qt的滚轮事件</h4>
<h5 id="qwheelevent"><code>QWheelEvent</code></h5>
<ul>
<li>在出发滚轮事件之后，我们通过一个<code>QWheelEvent</code>对象获取我们需要的关于滚轮的信息</li>
</ul>
<div>
<p>
  Wheel events are sent to the widget under the mouse cursor, but if
that widget does not handle the event they are sent to the focus widget.
Wheel events are generated for both mouse wheels and trackpad scroll
gestures. There are two ways to read the wheel event delta:
<code>angleDelta()</code> returns the deltas in wheel degrees. These
values are always provided. <code>pixelDelta()</code> returns the deltas
in screen pixels.
</p>
<p>
  
上述部分来自<code>Qt</code>官方文档,我们有两种方法可以获取鼠标滚轮的增量(正负代表方向)，<code>angleDelta()</code>，<code>pixelDelta()</code>.
</p>
</div>
<h6>
<code>QPoint QWheelEvent::angleDelta() const</code>
</h6>
<p>
<p>  Returns the relative amount that the wheel was rotated, in eighths
of a degree. A positive value indicates that the wheel was rotated
forwards away from the user; a negative value indicates that the wheel
was rotated backwards toward the user. angleDelta().y() provides the
angle through which the common vertical mouse wheel was rotated since
the previous event. angleDelta().x() provides the angle through which
the horizontal mouse wheel was rotated, if the mouse has a horizontal
wheel; otherwise it stays at zero. Some mice allow the user to tilt the
wheel to perform horizontal scrolling, and some touchpads support a
horizontal scrolling gesture; that will also appear in
angleDelta().x().</p>
  Most mouse types work in steps of 15 degrees, in which case the delta
value is a multiple of 120; i.e., 120 units * 1/8 = 15 degrees.
</p>
<ul>
<li>正值表示滚轮向上,远离用户. 负值向下,靠近用户.</li>
<li>此函数将返回两个方向上的滚动
<ul>
<li><font color=red>我们此处使用是垂直方向的滚动的角度 </font></li>
</ul></li>
<li>滚轮每次触发滚动的的角度是<span
class="math inline">\(15^\circ\left(delta\right)\)</span>，但是实际的返回值是
$delta = 120 $</li>
<li>返回的值应以 $ 1/8 $ 为单位:
<ul>
<li><span class="math inline">\(angleDelta() / 8\)</span>
得到鼠标实际滚动的度数</li>
</ul></li>
<li><code style="color:red">通过上面步骤便可以获取滚轮实际旋转的角度</code></li>
</ul>
<h3 id="将滚轮旋转角度映射到投影矩阵">2.
将滚轮旋转角度映射到投影矩阵</h3>
<ul>
<li><span class="math inline">\(ratio = delta/360^\circ\)</span></li>
<li>使用这个值去修改投影矩阵的参数</li>
<li>我们使用的是平行投影的方式
<ul>
<li><code>left</code></li>
<li><code>rght</code></li>
<li><code>bottom</code></li>
<li><code>top</code></li>
</ul></li>
</ul>
<h3 id="更新投影矩阵">3. 更新投影矩阵</h3>
<ul>
<li>在此之前 请将矩阵设置为单位矩阵 然后重新计算投影矩阵</li>
<li>更新投影矩阵</li>
<li>调用强制重新绘制(<code>Qt</code>) - <code>repaint()</code></li>
<li>你将得到放大后的场景</li>
</ul>
]]></content>
      <categories>
        <category>Computer Graph</category>
        <category>works</category>
        <category>SCU</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Bug奇遇记-uint16_t</title>
    <url>/2021/03/19/meet%20bug/Bug%E5%A5%87%E9%81%87%E8%AE%B0-uint16-t/</url>
    <content><![CDATA[<p>
  bug奇遇记之<code>uint16_t</code>...
</p>
<span id="more"></span>
<h3 id="uint16_t">uint16_t</h3>
<ul>
<li>标准定义中：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">short</span>  <span class="type">uint16_t</span>; <span class="comment">// max == _UI16_MAX 0xffffu </span></span><br></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/bug/uint_16/uint16_t.png"
title="uint16" alt="uint16_t" />
<figcaption aria-hidden="true">uint16_t</figcaption>
</figure>
<h4 id="问题">问题：</h4>
<ul>
<li><font color=red>这是一个粗心的问题</font></li>
</ul>
<p>在我正在实现的功能中有一个数据遍历的部分，我使用了<code>uint16_t</code>类型作为索引的类型，但是<code>uint16_t</code>数据的最大值比较小，所以当基础数据量过大的时候，我们产生的索引会越过索引的最大范围，导致最终得到的索引不是实际需要的索引值，导致我最终绘制的图形不是正确的结果！</p>
<hr />
<h3 id="正确的结果展示">正确的结果展示：</h3>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/bug/uint_16/lum_arrow_2.png"
title="result" alt="lum_2" />
<figcaption aria-hidden="true">lum_2</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/bug/uint_16/lum_arrow_1.png"
title="Result" alt="right result" />
<figcaption aria-hidden="true">right result</figcaption>
</figure>
<p>https://raw.githubusercontent.com/CuntBoy/images/main/blog/GF_Workspace.JPG</p>
]]></content>
      <categories>
        <category>works</category>
        <category>GF</category>
        <category>data type</category>
        <category>bugs</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>osg</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL Move Scene</title>
    <url>/2022/08/03/OpenGL/OpenGL-Move-Scene/</url>
    <content><![CDATA[<p>
  <code>OpenGL</code>场景移动...
</p>
<span id="more"></span>
<center>
<h1>
OpenGL Move Scene - 平面上移动
</h1>
</center>
<ul>
<li>我们考虑一个简单的平面的移动
<ul>
<li>某个维度为 <code>0</code>,我们只需要在某个平面上移动</li>
</ul></li>
</ul>
<h2 id="计算移动的方向">1. 计算移动的方向</h2>
<ul>
<li>在此之前对于相机的概念，希望您是熟悉的</li>
<li>虽然在<code>OpenGL</code>中本身并没有相机的概念
<ul>
<li><code>eye</code> - <code>point</code></li>
<li><code>center</code> - <code>point</code></li>
<li><code>up</code> - <code>vector</code></li>
</ul></li>
</ul>
<h3 id="计算相机的朝向">计算相机的朝向</h3>
<ul>
<li>右方向：<span class="math inline">\(\vec{front} = center -
eye\)</span></li>
</ul>
<h3 id="计算相机的右方向">计算相机的右方向</h3>
<ul>
<li><span class="math inline">\(\vec{right} = \vec{front} \times
\vec{up}\)</span></li>
<li>记得将向量<span
class="math inline">\(\vec{right}\)</span>归一化处理</li>
</ul>
<h2 id="鼠标的移动">2. 鼠标的移动</h2>
<ul>
<li>规定使用鼠标右键平移场景</li>
<li>我们使用<code>Qt</code>的鼠标事件
<ul>
<li>在<code>x</code>方向上，两次记录的位置相减携带了移动的方向</li>
<li>在<code>y</code>方向上，<code>Qt</code>窗口的原点与<code>OpenGL</code>的窗口存在差别，需要做额外的处理
- 反向</li>
</ul></li>
</ul>
<h3 id="当右键按下我们记录当前的鼠标的坐标">1.
当右键按下我们记录当前的鼠标的坐标</h3>
<h3 id="触发移动事件">2. 触发移动事件</h3>
<ul>
<li>此处每一次出发移动我们将计算一次场景的移动
<ul>
<li><code>X</code>方向 - <code>offsetX</code></li>
<li><code>Y</code>方向 - <code>offsetY</code></li>
</ul></li>
<li>更新我们记录的上一次的鼠标的位置</li>
</ul>
<h2 id="移动场景">移动场景</h2>
<ul>
<li>将这个移动映射成为数据的比例，作为移动方向的系数，作用到<code>eye</code>&amp;<code>center</code>,
重新计算视图矩阵，更新场景 ### 计算新的 <code>eye</code> &amp;
<code>center</code></li>
<li>计算沿着<span class="math inline">\(\vec{right}\)</span> &amp; <span
class="math inline">\(\vec{up}\)</span>方向的移动的距离</li>
<li>获取窗口的宽高为 <code>w&amp;h</code></li>
<li>在投影矩阵中 <span class="math inline">\(right - left =
spanX\)</span> &amp; <span class="math inline">\(top - bottom =
spanY\)</span> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">offsetX / w * spanX = disX;</span><br><span class="line">offsetY / h * spanY = disY;</span><br><span class="line"></span><br><span class="line">eye += right * disX + up *  disY;</span><br><span class="line">center += right * disX + up *  disY;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="更新视图矩阵repaint">更新视图矩阵&amp;<code>repaint</code></h2>
<ul>
<li><code>ViewMat.lookAt(eye,center,up)</code></li>
<li><code>repaint()</code></li>
</ul>
]]></content>
      <categories>
        <category>Computer Graph</category>
        <category>works</category>
        <category>SCUU</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>微信多开</title>
    <url>/2022/02/28/others/%E5%BE%AE%E4%BF%A1%E5%A4%9A%E5%BC%80/</url>
    <content><![CDATA[<p>
  Windows使用小技巧...
</p>
<span id="more"></span>
<h2 id="微信多开的小技巧---windows">微信多开的小技巧 - Windows</h2>
<ul>
<li><p>首先，需要你知道你机器上安装微信 - 请记录它的安装位置</p></li>
<li><p>一般情况下，如果你不做任何修改的话，它会在<code>C:\Program Files (x86)\Tencent\WeChat</code>这个目录下：
   <img
src="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/wechat_install_path.png"
title="微信安装位置" /></p></li>
<li><p>然后，打开你机器上任意的一个文本编辑器，输入如下内容：</p></li>
<li><p>需要多开多少个微信，你便将如下命令输入重复写多少次。</p>
<p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">start D:\&quot;Program Files (x86)<span class="string">&quot;\Tencent\WeChat\WeChat.exe</span></span><br><span class="line"><span class="string">start D:\&quot;Program Files (x86)&quot;</span>\Tencent\WeChat\WeChat.exe</span><br><span class="line"></span><br><span class="line"><span class="comment"># 请将上面的路径换成你机器上安装微信的路径</span></span><br><span class="line"><span class="comment"># 上面表示的是同时开两个微信程序</span></span><br><span class="line"><span class="comment"># 前面的路径部分中含有空格，为了让系统能识别，我们需要用双引号将其括起来，这样才能正确的识别</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></li>
<li><p>然后将文件保存，文件后缀为<code>.bat</code>,这是<code>cmd</code>识别的命令行，这个时候你打开你刚保存的文件，便会弹出你想要多开的数量。</p>
<p><img
src="https://raw.githubusercontent.com/CuntBoy/images/main/blog/computer_graph/games202/multi_open_wechat.png"
title="微信多开效果图" /></p></li>
</ul>
]]></content>
      <categories>
        <category>Tips</category>
      </categories>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL parallel  projection graphics do not scale with the window</title>
    <url>/2022/08/04/OpenGL/OpenGL-parallel-projection-graphics-do-not-scale-with-the-window/</url>
    <content><![CDATA[<p>
  <code>QtOpenGL</code>平行投影窗口缩放导致图形变形...
</p>
<span id="more"></span>
<center>
<h2>
OpenGL parallel projection graphics do not scale with the window
</h2>
</center>
<h3 id="实现步骤">实现步骤</h3>
<ul>
<li>重写窗口的<code>resize</code>事件
<ul>
<li>计算投影的范围</li>
</ul></li>
<li>更新投影矩阵</li>
<li><code>drawcull</code></li>
</ul>
<h4 id="resizegl"><code>resizeGL</code></h4>
<ul>
<li>我们最初计算一个比例：
<ul>
<li>关于窗口的<code>size</code>和投影的范围的
<ul>
<li>使用<code>left, right</code>计算一个<code>spanx(right - left)</code>,
<code>top, bottom</code>计算<code>spany(top - bottom)</code>,
分别与窗口的宽高比较 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> ratioW = w / spanx;</span><br><span class="line"><span class="keyword">auto</span> ratioH = h / spany; </span><br><span class="line"><span class="comment">// 取最小的一个 </span></span><br><span class="line"><span class="keyword">auto</span> ratio = std::<span class="built_in">min</span>(ratioW,ratioH);</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li>每次窗口缩放，我们就使用上述的范围计算新的<code>left,right,bottom,top</code>
<ul>
<li>只要投影的范围没有发生改变我们便不计算新的<code>ratio</code></li>
</ul></li>
</ul></li>
<li>计算新的<code>left,right,bottom,top</code> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">OpenGLWidget::resizeGL</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">glViewport</span>(<span class="number">0</span>,<span class="number">0</span>,w,h);</span><br><span class="line"></span><br><span class="line">    left = - w / ratio;</span><br><span class="line">    right = <span class="built_in">abs</span>(left);</span><br><span class="line">    bottom = -h / ratio;</span><br><span class="line">    top = <span class="built_in">abs</span>(bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="更新投影矩阵">更新投影矩阵</h4>
<ul>
<li>update
<ul>
<li>关于<code>zNear &amp; zFar</code>投影当二维平面时候，并未使用这两个参数
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">projMat.<span class="built_in">ortho</span>(left,right,bottom,top,<span class="number">0.1f</span>,<span class="number">100.0f</span>);</span><br></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<h4 id="更新绘制的场景">更新绘制的场景</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">shaderProgram.<span class="built_in">bind</span>(); </span><br><span class="line">shaderProgram-&gt;<span class="built_in">setUniformValue</span>(<span class="string">&quot;projectionMatrix&quot;</span>, projMat); </span><br><span class="line"><span class="built_in">glDrawArray</span>()</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Computer Graph</category>
        <category>works</category>
        <category>SCUU</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
      </tags>
  </entry>
  <entry>
    <title>cmake 文件操作</title>
    <url>/2022/09/10/C++/CMake/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>记录一下在日常的工作中用到的一些<code>cmake</code>的关于文件操作的命令(基本<code>Copy</code>,<code>move</code>,<code>remove</code><span
class="math inline">\(\dots\)</span>)</p>
<span id="more"></span>
<h2 id="cmake-文件操作"><code>cmake</code> 文件操作</h2>
<ul>
<li>通常使用<code>FILE</code>命令完成相关的参数.</li>
</ul>
<h3 id="copy-file"><code>Copy</code> File</h3>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FILE</span>(&lt;COPY|<span class="keyword">INSTALL</span>&gt; &lt;files&gt;... DESTINATION &lt;dir&gt;</span><br><span class="line">     [FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]</span><br><span class="line">     [FOLLOW_SYMLINK_CHAIN]</span><br><span class="line">     [FILES_MATCHING]</span><br><span class="line">     [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">    [EXCLUDE] [PERMISSIONS &lt;permissions&gt;...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># The COPY signature copies files, directories, and symlinks to a destination folder. </span></span><br><span class="line"><span class="comment"># Relative input paths are evaluated with respect to the current source directory, and a relative destination is evaluated with respect to the current build directory. </span></span><br><span class="line"><span class="comment"># Copying preserves input file timestamps, and optimizes out a file if it exists at the destination with the same timestamp.</span></span><br><span class="line"><span class="comment"># Copying preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS are given (default is USE_SOURCE_PERMISSIONS).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If FOLLOW_SYMLINK_CHAIN is specified, COPY will recursively resolve the symlinks at the paths given until a real file is found, and install a corresponding symlink in the destination for each symlink encountered.</span></span><br><span class="line"><span class="comment"># For each symlink that is installed, the resolution is stripped of the directory, leaving only the filename, meaning that the new symlink points to a file in the same directory as the symlink. </span></span><br><span class="line"><span class="comment"># This feature is useful on some Unix systems, where libraries are installed as a chain of symlinks with version numbers, with less specific versions pointing to more specific versions. </span></span><br><span class="line"><span class="comment"># FOLLOW_SYMLINK_CHAIN will install all of these symlinks and the library itself into the destination directory. </span></span><br><span class="line"><span class="comment"># For example, if you have the following directory structure:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>file</code>命令的<code>copy</code>操作会将文件，目录，或者是符号链接复制到目标目录，相对输入路径是相对于当前源目录(<code>cmake文件</code>)，复制会保留输入文件的时间戳，如果文件存在于目标位置且具有相同的时间戳，则会对其进行优化。复制行为默认保留默认权限，除非手动指定(<code>NO_SOURCE_PERMISSIONS</code>)。</li>
</ul>
<h4 id="example">example</h4>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 拷贝一个目录(&#123;CMAKE_SOURCE_DIR&#125;/resources/Fonts)到&quot;&#123;CMAKE_SOURCE_DIR&#125;/bin/resources/&quot;路径下</span></span><br><span class="line"><span class="keyword">FILE</span>(COPY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/resources/Fonts DESTINATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin/resources/)</span><br></pre></td></tr></table></figure>
<ul>
<li>load <span class="math inline">\(\dots\)</span> <span
class="math inline">\(\dots\)</span></li>
</ul>
]]></content>
      <categories>
        <category>CMake</category>
      </categories>
      <tags>
        <tag>fileSystem</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenGL的手动初始化</title>
    <url>/2022/11/03/OpenGL/OpenGL%E7%9A%84%E6%89%8B%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="opengl初始化">OpenGL初始化</h2>
<ul>
<li>在使用OpenGL前我们通常需要配置好OpenGL的环境 -
创建一个提交命令的客户端，我们需要完成的事情包括如下部分(此处我们介绍关于Windows的操作)：
<ul>
<li>创建一个窗口(for windows)</li>
<li>获取窗口的<code>Device Context</code></li>
<li>使用<code>Device Context(HDC)</code>创建
<code>OpenGL Render Contesxt(HRLRC)</code></li>
<li>绑定<code>HDC &amp; HGLRC</code>到当前线程</li>
</ul></li>
<li>完成上述的设置之后，便可以调用<code>OpenGL</code>进行渲染</li>
</ul>
<h3 id="创建opengl可用的窗口---win">1、
创建<code>OpenGL</code>可用的窗口 - <code>Win</code></h3>
<h4 id="注册窗口类">1.1 注册窗口类</h4>
<ul>
<li><code>HINSTANCE</code>对象实例化</li>
<li>填充<code>WNDCLASS</code>结构体</li>
<li>注册窗口类</li>
</ul>
<h4 id="创建窗口">1.2 创建窗口</h4>
<h4 id="设置像素格式">1.3 设置像素格式</h4>
<p><font color=red>loading 待续</font></p>
]]></content>
  </entry>
  <entry>
    <title>迟到的毕业总结</title>
    <url>/2021/03/18/Life/2020/%E8%BF%9F%E5%88%B0%E7%9A%84%E6%AF%95%E4%B8%9A%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>
  毕业!,一个不欢而散，再也不见的话题...
</p>
<span id="more"></span>
<h3 id="简单的毕业">简单的毕业</h3>
<p>
<p>  <font color=red>2020年</font>在三个月前结束了，这一年大家都收获了满满的经历。当然，我也是。我毕业了，从一个三流学校的渣子变成了社会末流的青年。开始了独属于我的关于这个时代的苟且！</br>
  离开前，大家都像是急于归乡的游子，对身后的这个城市未有半点留恋。</br>
  对于大学，我仿佛有千言万语，却是欲语还休
。不谈这个这个有些无聊的学校，关于大学，关于这四年，关于我自己，我希望它是美好的，会让我主动怀恋的！</p>
待续。。。
</p>
<hr />
<h3 id="section"><code>2021-7-26</code></h3>
<p>
<p>​  下个月就要离开这个城市了，目前心情很是平淡，谈不上悲，亦没有欢喜，我仿佛早有预料一般。却如其实，我的确早有离开的想法，我大学的四年在这个城市度过，对于这里的大部分事物，我也算是熟悉，离开这里对我来说麻烦的地方便是新的城市，新的交际。。。
当然一切都会是新的，我也是。</p>
  祝愿我将迎接新的美好，朋友我来了！
</p>
<h3 id="这是什么样子的四年呢"><code>这是什么样子的四年呢？</code></h3>
<h4 id="section-1"><code>2022-8-14</code></h4>
<p>
<p>  转眼之间，我毕业两年，放眼望去，我得到了什么呢？</p>
</p>
]]></content>
      <categories>
        <category>bun</category>
        <category>university</category>
      </categories>
      <tags>
        <tag>university</tag>
        <tag>conclusion</tag>
      </tags>
  </entry>
  <entry>
    <title>ColorBlend</title>
    <url>/2024/01/12/Computer%20Graphics/transparent%20object%20render/ColorBlend/</url>
    <content><![CDATA[<h2 id="颜色混合">颜色混合</h2>
<p>在传统的渲染管线中，如果场景中的所有物体都不透明，那么最终渲染的结果是根据<code>Z-buffer</code>算法比较深度，显示的片元的颜色是离相机的最近的片元的颜色。</p>
<p>如果场景中存在半透明物体(颜色的<code>alpha</code>值小于<code>1.0</code>)的时候，比如模拟渲染一个透过玻璃观察的场景，正确的场景是我们可以透过玻璃观察到玻璃后面的世界，要正确的渲染这个场景，需要将玻璃的颜色和玻璃后面的场景进行颜色的混合，混合既是混合多种颜色为一种，从而渲染我们认为正确的结果。</p>
<p>透明物体可以半透明也可以是全透明的，全透明下光线会完全穿透，是指这个透明物体的颜色不参与整个混合，也就是透明物体本身的颜色不对混合的结果有任何的贡献，除去全透明物体剩下的就是半透明物体，半透明物体本身的颜色参与最终颜色的合并，会对生成的结果产生一定的贡献，具体的数量要根据混合算法计算。</p>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/transparent/blending_transparency.png"
title="blending transparency" alt="&quot;blending transparency&quot;" />
<figcaption aria-hidden="true">"blending transparency"</figcaption>
</figure>
<p>在<code>OpenGL</code>中颜色混合一般都是使用<code>ADD</code>的方式,使用片元的<code>alpha</code>作为混合的因子。</p>
<ul>
<li><p><code>ADD</code>既是取这两个需要合并的像素，根据因子分别计算一个值<span
class="math inline">\(C_{src},C_{dst}\)</span>，输出最终的颜色<span
class="math inline">\(C_{out} = C_{src} +
C_{dst}\)</span>，可以分别为<code>RGB</code>通道和<code>alpha</code>通道分别设置混合因子</p></li>
<li><p><code>ADD</code>被称为混合混合方程，可以分别为<code>RGB</code>通道和<code>alpha</code>通道分别设置混合方程</p></li>
</ul>
<p>因为在渲染过程中<code>画家&amp;z-buffer</code>算法的实现方式，当我们有一个半透明的场景，并且我们想要正确显示场景中的物体的颜色，我们必须对场景中的物体进行排序,保证优先渲染最远的物体，此时我们通常可以得到一个正确的渲染结果。</p>
]]></content>
      <categories>
        <category>Computer Graph</category>
        <category>works</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式-单例模式</title>
    <url>/2022/08/19/C++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>考虑某种场景，我们需要一个工具类，对于所有模块提供同样的接口与数据，但是如果每个模块使用这个类的功能的时候都创建一整个类，此种行为虽说是合法的，但并不是最好的选择，我们可以通过单例设计模式，将这个类变为一个单例，我们每一次创建这个类的实例的时候，都只是获取之前创建的，从而调用相应的功能。
<span id="more"></span></p>
<h2 id="单例模式">单例模式</h2>
<ul>
<li>单线程版本</li>
<li>多线程版本</li>
<li>双检查锁</li>
<li><code>C++11</code>之后的版本</li>
<li><code>std::call_once</code></li>
</ul>
<h3 id="实现">实现</h3>
<ul>
<li>单线程版本
<ul>
<li>此版本只是单线程安全</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton * <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">sprivate:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>多线程版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex m_mutex;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.<span class="built_in">unlock</span>();</span><br><span class="line">        lock.<span class="built_in">release</span>();</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>多线程版本优化版 - 双检查锁</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line">std::mutex m_mutex;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!m_singleton)</span><br><span class="line">            &#123;</span><br><span class="line">                m_singleton = <span class="keyword">new</span> Singleton;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.<span class="built_in">unlock</span>();</span><br><span class="line">            lock.<span class="built_in">release</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> m_singleton;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    Singleton* m_singleton&#123; <span class="literal">nullptr</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>C++11</code>版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton m_instance;</span><br><span class="line">        <span class="keyword">return</span> m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>std::call_once</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::<span class="built_in">call_once</span>(flag, []() &#123;m_instance.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Singleton</span>()); &#125;);</span><br><span class="line">        <span class="keyword">return</span> *m_instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line">    Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;&amp; another) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> std::unique_ptr&lt;Singleton&gt; m_instance;</span><br><span class="line">&#125;;</span><br><span class="line">std::unique_ptr&lt;Singleton&gt; Singleton::m_instance;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年终总结</title>
    <url>/2022/01/16/Life/2021/2021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>
  毕业后的第一年，我开始了自己的苟且与悲歌...
</p>
<span id="more"></span>
<h3 id="我起伏的2021年">我起伏的2021年:</h3>
<ul>
<li>2021年鸡毛蒜皮</li>
</ul>
<p>....</p>
<h3 id="我的关于2021年的大事件">我的关于2021年的大事件：</h3>
<h4 id="换了工作">1、换了工作</h4>
<h4 id="离开了那个度过了五年的城市">2、离开了那个度过了五年的城市</h4>
<h4 id="换了工作的城市">3、 换了工作的城市</h4>
<h4 id="告别了好友">4、告别了好友</h4>
<h4 id="见了阔怕已久的朋友">5、见了阔怕已久的朋友</h4>
<h4 id="又一次决定换工作">6、又一次决定换工作</h4>
<ul>
<li>面试了一个环境可能更好的工作</li>
</ul>
<h3 id="一我换工作这件事">一、我换工作这件事</h3>
<p>
先我说我自己吧,一个cpp开发人员,大学毕业之后在济南的一家做仿真的公司,做一些图形相关的工作,这就是我的第一份工作。
</p>
<p>  离开我的上一个岗位的原因颇多,当然究其原因，我觉得<code>马老板</code>说的话能够很好的概括我当时的处境， 比较这年头找一份工作很容易，但是找到一份好工作还是比较困难的。
  新工作也是做仿真的,只是方向有所不同,但是对于一个开发人员,又有什么太大的区别呢,毕竟，核心的算法部分会有专门的人负责，而我知识负责一些图形相关的工作，展示一下仿真的结果。</p>
<h3 id="二离开济南">二、离开济南</h3>
<p>  我在这个城市上大学，大学毕业在这里找的工作，也是在这里，。
  若是在学校还好，但是在济南生活，我大概是不适合这个城市了，离开济南不一定是因为我要换掉我之前的工作，也可能是由于我想离开这个城市，寻求更好的发展，或者是我本人有更高的追求，我在这个城市呆了很长时间，熟悉这里的大部分东西，这里的风土人情以及这里的那浓郁的不合于我的生活气息......
  我算是个重庆人，也许更适合我的地方是川蜀之地，况且我还比较佛系，所以<code>成都</code>应该是个不错的选择，我开始面试，将目标公司地域选到了成都.....
  然后我选择了一家成都的公司，在一个我去打完疫苗的间隙，足够我用这个时间做很多事情。
  然后我来了<code>北京</code>.....,只能说，造化弄人。</p>
<h3 id="三告别好友">三、告别好友</h3>
<p>  我也算是个热爱生活的人，离别前夕，怎么也会告别这个城市最后的朋友，我们宿舍的<code>二哥</code>还有<code>杨哥</code>,还有隔壁宿舍后面相熟的朋友，大家约在烧烤摊一起畅想了我们的未来的几年。
  从济南公司离职后，去德州见了好久不见的另一个舍友，在那里度过了一个周末，互相倾诉，对于我们彼此的不容易，都是略有耳闻。</p>
<h3 id="四见了好久不见的朋友">四、见了好久不见的朋友</h3>
<p>  2021年8月20日,在北京,我开启了我长达6个月的出差，我刚毕业的时候，我曾经有过想要在北京工作的想法，但是一些原因，我放弃了，同时，也觉得自己以后可能都不会在北京停留，第一次来北京是在16年的时候，我在北京度过了国庆，下了6天雨，这几天北京给我的印象只有雾霾。
  有人说离别是为了更好的相遇，所以，有时候缘分很重要，大学同学毕业前在北京实习，毕业的时候北京疫情，最后的毕业照都是P上去的，28个人唯独缺了他，挺好的，大家又一次重逢。
  同样是在这里，遇到了另一位朋友，亦师亦友，感谢相遇。</p>
<h3 id="五又一次决定换工作">五、又一次决定换工作</h3>
<p>  决定让自己的未来有更多的选择,于是决定做一些尝试，希望能有个好结果。
  又一次选择了面试，结果还挺不错，虽然没能拿到想要的待遇，但是是我喜欢的地点，拥有我喜欢的条件，甚好！！！</p>
]]></content>
      <categories>
        <category>bun</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>mylife</tag>
      </tags>
  </entry>
  <entry>
    <title>我的2022</title>
    <url>/2023/01/11/Life/2022/%E6%88%91%E7%9A%842022/</url>
    <content><![CDATA[<ul>
<li>2022发生了很多事情，关于我的和关于我周围的朋友的，大多都是欢喜的，值得怀念。</li>
</ul>
]]></content>
      <categories>
        <category>bun</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>mylife</tag>
      </tags>
  </entry>
  <entry>
    <title>起伏的2022(上)</title>
    <url>/2022/08/14/Life/2022/2022%E5%8D%8A%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<center>
<h1>
关于我的2022(上)
</h1>
</center>
<p>
  2022年发生诸多事情，令人成长的事情居多，在这中间的末尾，却也有足够的惊喜将这一连串的不快掩盖......
</p>
<span id="more"></span>
<h2 id="上一览">2022上，一览</h2>
<ul>
<li>辞掉了原来的工作
<ul>
<li>离开了北京</li>
<li>又去见了一些人</li>
</ul></li>
<li>来了成都</li>
<li>给自己翻篇</li>
<li>遇到了她
<ul>
<li>准备一起写我们的故事</li>
</ul></li>
</ul>
<h3 id="离开我不喜欢的北京">离开我不喜欢的北京</h3>
<h4 id="辞职那点事">辞职那点事</h4>
<p>
  其实之前也算是成都的一家公司，只是有些草率，我的入职合同是通过快递签订的。除了和我一起出差的同事，我并未见过任何一个公司的同事。我以为我的入职之后会是在成都度过，但是事实总是不能遂了人意，我在一直呆在北京，算是出差中，可能是呆的时间有点太长了，我决定要离开了。于是在去年年底的最后一个月开始重新找工作了，依旧是在成都，重新觅一份新的工作，阴差阳错，来了现在的公司，年前的2月，我们结束我们的年假，决定前往北京进行工作最后的工作交接。我深知那一次的离开，我可能再也不会再来北京，离开前总是需要见一些该见的人，就当作是最后的告别。
</p>
<h4 id="往后不能再见的朋友">往后不能再见的朋友</h4>
<p>
  记得大一的第一学期的前半程是稍微有些无聊的，我去往那个和我期待中的样子差距颇大的地方，我在颓废中度过了大一第一学期的前半程，可能是接受了现实，我决定改变一下这个现状，于是迈出了我成为程序员得第一步，我找了个学生组织，参与进去。可能是缘分，我遇到好些个有意思的人，在这之中有我的好朋友，也有带我入行的学长，毕业后，学长去了北京。虽然在我本来的计划中，我大概会去北京的，但事情总是不得遂人意，阴差阳错，我没能去了。借此机会，见了这位阔别已久的老朋友，一起聊到凌晨，大家总有各自的生活，所以分别，多少没那么不舍。我相信缘分会拉着我们一次又一次的相遇。
</p>
<p>
  那位没能和我们一起拍毕业照的小伙伴，也将见证我的离去，我们是大学同学，男孩子性格的她，和我们最是合得来，一起吃了个饭，记得是我此前没有尝试过的港式，没有什么不舍，惟愿。
</p>
<h3 id="终来成都">终来成都</h3>
<h4 id="新工作">新工作</h4>
<ul>
<li>还是那个工作，只是换了环境和一波同事，对我来说,差别不大。来时是三月中旬，成都总是那么出人意料，我来时给予我最大的温暖，$
28^o $的天气，只有感谢，未能有更多言语。</li>
<li>来后三个月的感叹，<code>我好菜呀！！！！！！！</code></li>
</ul>
<h3 id="给自己翻篇">给自己翻篇</h3>
<ul>
<li>经历变得丰富，成长颇多，感谢！</li>
<li>毕业两年！！！！！！！！！！！！！！！！！！！！！！！！！</li>
</ul>
<h3 id="遇到她">遇到她</h3>
<ul>
<li>如果我没有离开北京，如果我没有来这里，所以一切都是刚好的样子，感谢缘分让我们相遇。我们很合拍，无论什么。</li>
<li>所以想写新的故事，就我和她，在这个城市的故事。
<ul>
<li>所以感谢会会的早餐与陪伴</li>
</ul></li>
</ul>
<h3 id="over">Over</h3>
<ul>
<li>2022的上半年到我们在一起结束，这是我2022年最开心的时候，感谢缘分，感谢相遇！</li>
</ul>
]]></content>
      <categories>
        <category>bun</category>
        <category>life</category>
      </categories>
      <tags>
        <tag>mylife</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-工厂模式</title>
    <url>/2022/08/19/C++/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>什么是工厂模式？
工厂顾名思义，就是创建产品。该模式封装和管理对象的创建，通俗地讲就是，你<code>new</code>一个对象的时候，直接调用工厂方法就行了。</p>
<span id="more"></span>
<h2 id="工厂模式">工厂模式</h2>
<ul>
<li>当我们需要不停的创建不同的对象的时候，我们可以通过封装接口，然后调用函数返回不同的类型的对象，这个时候我们就需要工厂模式帮我们处理此问题</li>
</ul>
<h3 id="简单工厂模式">1. 简单工厂模式</h3>
<ul>
<li>将类的初始化和创建全部交给一个工厂来完成，我们只需要告诉工厂我们需要什么即可。</li>
<li>专门定义一个类来负责创建其他类的实例，被创建的实例通常具有共同的父类。</li>
<li>是一种实例化对象的方式，只要输入需要实例化对象的名字，就可以通过工厂对象的相应工厂函数来制造你需要的对象。</li>
</ul>
<h4 id="工厂factory">1. 工厂(<code>Factory</code>)</h4>
<ul>
<li>负责创建所有实例的内部逻辑，工厂类可以被外界直接调用，创建所需要的产品对象。</li>
<li>创建出产品(<code>Product</code>) -&gt;
具体的产品(<code>ConcreteProduct</code>)</li>
</ul>
<h4 id="产品">2. 产品</h4>
<h5 id="抽象产品">抽象产品</h5>
<ul>
<li>象产品角色是简单工厂模式所创建的所有对象的父类，负责描述所有实例所共有的公告接口。所创建的具体产品对象都是其派生对象。</li>
</ul>
<h5 id="具体产品">具体产品</h5>
<ul>
<li>具体产品是简单工厂模式的创建目标。每个具体产品都继承了抽象产品，需要实现定义在抽象产品中的方法。</li>
</ul>
<h4 id="使用">3. 使用</h4>
<ul>
<li>当我们需要创建的对象数量较多且杂的时候，我们需要使用简单工厂模式来创建对象。</li>
<li>对象的创建过程是我们不需要去关心，我们注重的是对象的实际操作，所以，我们需要分离对象的创建和操作两部分，方便后期的程序扩展和维护。</li>
</ul>
<h4 id="code">4. <code>Code</code></h4>
<ul>
<li>Product</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">product_type</span></span><br><span class="line">&#123;</span><br><span class="line">    none,</span><br><span class="line">    one,</span><br><span class="line">    two</span><br><span class="line">    <span class="comment">// ...... </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Product</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Product</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string &amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductA</span> <span class="keyword">final</span> :<span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ProductA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProductB</span> <span class="keyword">final</span> :<span class="keyword">public</span> Product</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">ProductB</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> std::string&amp; <span class="title">name</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_name;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string m_name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>Factoy.h</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">Factoy.h</span><br><span class="line">---</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Factory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">Factory</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span>  Product* <span class="title">crteateProduct</span><span class="params">(product_type &amp; type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(type == product_type::one)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span>  ProductA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(type == product_type::two)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ProductB;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Product* <span class="title">crteateProduct</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li><code>main</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> factory = <span class="keyword">new</span> Factory;</span><br><span class="line">    <span class="keyword">auto</span> product_a = factory-&gt;<span class="built_in">crteateProduct</span>(product_type::none);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="工厂方法模式">2. 工厂方法模式</h3>
<h4 id="简介">2.1 简介</h4>
<ul>
<li>简单工厂模式中最大的缺点就是当我们需要创建新的产品的时候，我们需要修改工厂的<code>create</code>方法，加入必要的处理逻辑，违背了设计原则-<code>开闭原则</code></li>
<li>工厂方法模式中，工厂父类只是定义创建产品的接口，子类负责创建具体的产品，将具体产品的创建都延迟到子类中实现，通过子类创建具体的实例化对象。</li>
</ul>
<h4 id="实现">实现</h4>
<ul>
<li><code>concreteFactory.h</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Factory.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FactoryA</span> <span class="keyword">final</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FactoryA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    ~<span class="built_in">FactoryA</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function">Product* <span class="title">crteateProduct</span><span class="params">()</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ProductA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>main.cpp</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Factory.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;concreteFactory.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> factory = <span class="keyword">new</span> FactoryA;</span><br><span class="line">    <span class="keyword">auto</span> product_a = factory-&gt;<span class="built_in">crteateProduct</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽象工厂模式">3. 抽象工厂模式</h3>
<ul>
<li>一个特殊的工厂模式</li>
<li>创建一个产品族</li>
<li>待续</li>
</ul>
]]></content>
      <categories>
        <category>Design Patterns</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>第一次换工作</title>
    <url>/2021/10/17/Life/History%20of%20Work/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%80%BB%E7%BB%93_%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8D%A2%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>
  而二分工作的小总结，北京...
</p>
<span id="more"></span>
<h3 id="section"></h3>
<p><code>前记：</code></p>
<p><img src="https://raw.githubusercontent.com/Ranbun/images/main/works/GF/GF_Workspace.JPG"/></p>
<p>    从辞职到新公司，过去了快两个月时间，经过这大段的时间，度过了试用期，开始接手往后日子里要进行的工作。</p>
<p> 
   新工作是关于<code>C++　&amp;　OSG</code>的，做一个仿真软件，主要负责一些关于<code>osg</code>的渲染工作，和其中部分界面的编写，项目用到的还算是熟悉的东西：</p>
<ul>
<li><code>Qt</code>编写整个软件的界面</li>
<li><code>osg</code>负责整个3D图形的展示</li>
</ul>
<p>  关于这个项目遇到的一些问题：</p>
<ul>
<li><code>osg</code>编译劝退</li>
</ul>
<p>    讲真，<code>osg</code>的库的编译相当劝退，各种库的依赖关系，以及<code>VS</code>的工具链的选择，以及部分库的调试模式的选择。</p>
<p>这里推荐<a ref=https://freesouth.blog.csdn.net/>杨石兴的博客</a>详细介绍了OSG的编译的一些问题，同时它提供了编译使用的所有的依赖包，各种工具集的版本。</p>
<ul>
<li><code>osg</code>与<code>Qt</code>的集成</li>
</ul>
<p>    要求你先编译<code>osg</code>然后才能编译，<code>osgQt</code>在<code>osg3.4</code>之后的版本中便被从原来的库中剔除，需要自己单独编译，</p>
<p>同时<code>Qt4.0</code>的版本与<code>5.0</code>的版本编译使用的<code>Qt</code>的类也存在一些区别。</p>
<p>当前阶段，上面提到的这些问题，我们已经解决了，新一番的问题产生了：</p>
<ul>
<li>在于不同的团队合作的时候，如何扯皮！</li>
</ul>
]]></content>
      <categories>
        <category>works</category>
        <category>HJ</category>
      </categories>
      <tags>
        <tag>conclusion</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt</title>
    <url>/2021/07/27/Life/History%20of%20Work/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95_Qt/</url>
    <content><![CDATA[<p><em>和老大提出辞职之后，商量了关于我的工作后续的事情，便开始寻找新工作......</em>
目的地是在重庆的一家公司，具体什么名字，暂时不透露了，面的<code>C++ &amp; Qt</code>，按照面试官的说法，这是一个纯<code>Qt</code>的岗位，所以接下来的问题大概全部是和<code>Qt</code>相关的，当然也会有部分C++的问题在其中。</p>
<span id="more"></span>
<p><font style="color:pink">废话不多说，我们进入正题：</font></p>
<h2 id="c部分的问题">C++部分的问题：</h2>
<ul>
<li><p>第一部分是关于C++这门语言的，面向对象是什么？</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// OOP</span></span><br><span class="line"><span class="comment">// 封装,继承,多态</span></span><br></pre></td></tr></table></figure></li>
<li><p>对于多态的理解?</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先是如何实现多态？</span></span><br><span class="line"><span class="number">1.</span> 多态发生在继承关系中。</span><br><span class="line"><span class="number">2.</span> 需要重写虚函数。</span><br><span class="line"><span class="number">3.</span> 父类的指针指向子类的对象。</span><br><span class="line"><span class="number">4.</span> 通过父类指针对重写的虚函数发起调用，最终调用你要想调用的函数。</span><br></pre></td></tr></table></figure>
<p>example： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">A</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;A&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function_virtual</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          std::cout&lt;&lt;<span class="string">&quot;function_A&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> menber;</span><br><span class="line">  </span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">B</span>():<span class="built_in">A</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;B&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function_virtual</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          std::cout&lt;&lt;<span class="string">&quot;function_B&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">D</span>: <span class="keyword">public</span> A</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">D</span>():<span class="built_in">A</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;D&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line">  </span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">function_virtual</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          std::cout&lt;&lt;<span class="string">&quot;function_D&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      A * a = <span class="keyword">new</span> A;</span><br><span class="line">      B * b = <span class="keyword">new</span> B;</span><br><span class="line">      D * d = <span class="keyword">new</span> D;</span><br><span class="line">  </span><br><span class="line">      A * ptr = b;</span><br><span class="line">      ptr-&gt;<span class="built_in">function_virtual</span>();</span><br><span class="line">  </span><br><span class="line">      ptr = a;</span><br><span class="line">      ptr-&gt;<span class="built_in">function_virtual</span>();</span><br><span class="line">  </span><br><span class="line">      ptr = d;</span><br><span class="line">      ptr-&gt;<span class="built_in">function_virtual</span>();</span><br><span class="line">  	</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure></p>
<p><font style="color:red">结果如下：</font> <img
src="https://raw.githubusercontent.com/Ranbun/images/main/cpp/polymorphism.png"
title="polymorphism" alt="polymorphism" /></p></li>
<li><p>多态的实现 -- <font style="color:red">虚函数表</font></p>
<ul>
<li><p>验证虚函数表：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个简单的C 不带有虚函数 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">C</span>()&#123;std::cout&lt;&lt;<span class="string">&quot;C&quot;</span>&lt;&lt;std::endl;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> member;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><font style="color:red">输出结果:</font> <img
src="https://raw.githubusercontent.com/Ranbun/images/main/cpp/virtual_table_1.png"
title="virtual table 1" alt="virtual_table" /></p>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/cpp/virtual_table_2.png"
title="virtual table 2" alt="virtual table 2" />
<figcaption aria-hidden="true">virtual table 2</figcaption>
</figure>
<ul>
<li>上面的结果可以看出存在一个成员(存在虚函数的情况)，大小为8个字节(64位软件)。</li>
</ul></li>
</ul></li>
</ul>
<hr />
<h2 id="qt部分">Qt部分</h2>
<ul>
<li>元对象系统</li>
<li>窗口刷新机制</li>
<li>内存托管(删除机制)</li>
<li>Qquick</li>
<li>Qt的布局</li>
</ul>
<h2 id="opengl部分">OPENGL部分</h2>
<ul>
<li><p>缓冲(双缓冲)</p></li>
<li><p>着色器程序(语言)</p></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>渲染(CAD)</title>
    <url>/2022/01/16/Life/History%20of%20Work/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95_CAD%E6%B8%B2%E6%9F%93/</url>
    <content><![CDATA[<p>
  一次面试的记录...
</p>
<span id="more"></span>
<h2 id="记一次面试">记一次面试:</h2>
<p>  距离上一次面试，不到半年，频繁的换工作，总是一件不好的事情，关于换工作这件事并不是那么的难以启齿，所以具体原因就先省略了.......
  这次的目标是国内的一所高校，具体的工作，根据面试的情况看来，是<code>CAD</code>方向，大概都是渲染相关的，所以还是符合我的预期。</p>
<h2 id="start-interview">Start Interview:</h2>
<ul>
<li>首先这是一个<code>Cpp</code>&amp;<code>图形</code>的混合岗位，所以能想到的是，关于对这个岗位的基本要求就是<code>CPP</code>和<code>图形学</code>开发经验,
可以预见大概的问题就是<code>Cpp</code>和图形相关的知识。</li>
</ul>
<hr />
<h3 id="第一次面试">第一次面试</h3>
<h4 id="关于简历中提到的之前的项目">关于简历中提到的之前的项目</h4>
<ul>
<li>部分和之前项目相关的问题</li>
<li>一些技术上的解决方案</li>
<li>......</li>
</ul>
<h4 id="cpp的新的语言特性">CPP的新的语言特性</h4>
<ul>
<li><code>C++11</code>的新语言特性 - 比较常用的
<ul>
<li>智能指针</li>
<li><code>auto</code>自动类型推导</li>
<li>标准库的多线程</li>
<li><code>lambda</code>表达式</li>
</ul></li>
<li>一些指针和引用相关的问题
<ul>
<li>指针是什么？</li>
<li>引用是什么？</li>
<li>两者的区别？</li>
<li>内存分区的相关问题，如：
<ul>
<li>常量在程序中的的存储位置</li>
<li>静态变量在什么位置</li>
<li>......</li>
</ul></li>
</ul></li>
</ul>
<h4 id="图形相关的问题">图形相关的问题</h4>
<ul>
<li>图形管线的问题
<ul>
<li>坐标变换相关的问题
<ul>
<li>投影</li>
<li>视图</li>
</ul></li>
</ul></li>
<li>一些渲染上面的解决方案
<ul>
<li>大数据量的绘制</li>
</ul></li>
</ul>
<h3 id="第二次面试">第二次面试</h3>
<p>  第二次面试倒是没有什么技术相关的问题，两个老师，一个人事，加上我，一共四个人，具体内容就是一个10分钟的自我介绍，这个介绍包括：</p>
<ul>
<li>个人介绍
<ul>
<li>基本信息</li>
<li>求学经历</li>
<li>......</li>
</ul></li>
<li>工作经历
<ul>
<li>项目经历</li>
</ul></li>
<li>未来的规划
<ul>
<li>职业规划</li>
<li>个人规划</li>
</ul></li>
<li>个人爱好</li>
</ul>
<p> .......</p>
<p>  后面部分就是关于这个介绍的提问了，无关痛痒。</p>
<p>  一周以后......，在我以为黄了的时候，竟然通过了。</p>
<p>  感谢！</p>
]]></content>
      <categories>
        <category>works</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>computer graphics</tag>
        <tag>openGL</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt OpenGL Antialiasing-MSAA</title>
    <url>/2022/08/02/OpenGL/Qt%20OpenGL/Qt-OpenGL-Antialiasing-MSAA/</url>
    <content><![CDATA[<p>
  <code>QtOpenGL</code>MSAA算法介绍...
</p>
<span id="more"></span>
<h2 id="qt-opengl-antialiasing---msaa">Qt OpenGL Antialiasing -
MSAA</h2>
<h3 id="锯齿是图形绘制中常见的问题">锯齿是图形绘制中常见的问题</h3>
<ul>
<li>这是一个采样不足然后信号丢失导致的问题</li>
<li>经过各位前辈们的其扑后继的研究，终究是有了看起来不错的解决方案</li>
<li>本文中我们采用一种名为<code>MSAA</code>的抗锯齿的技术</li>
</ul>
<h3 id="msaa"><code>MSAA</code></h3>
<p>
  超级采样抗锯齿（Super Sampling
Anti-Aliasing）的原理是把当前分辨率成倍提高,然后再把画缩放到当前的显示器上。这样的做法实际上就是在显示尺寸不变的情况提高分辨率，让单个像素变得极小，这样就能够大幅减轻画面的锯齿感了。不过是由于对整个显示画面的放大，因此它消耗的显示资源也是非常大的。
</p>
<h3 id="qt-openggl-的-msaa"><code>Qt OpengGL</code> 的
<code>MSAA</code></h3>
<h4 id="走样展示">走样展示</h4>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing.png"
title="线的走样" alt="走样" />
<figcaption aria-hidden="true">走样</figcaption>
</figure>
<h4
id="开启qtopenglwidget的msaa">开启<code>QtOpenGLWidget</code>的<code>MSAA</code></h4>
<figure>
<img
src="https://raw.githubusercontent.com/Ranbun/images/main/blog/OpenGL/OpenGLAntialiasing-MSAA.png"
title="MSAA" alt="MSAA" />
<figcaption aria-hidden="true">MSAA</figcaption>
</figure>
<h4
id="如何开启qtopengl的msaa">如何开启<code>QtOpenGL</code>的<code>MSAA</code></h4>
<ul>
<li><p><code>Qt</code>有他自己的关于<code>OpenGL</code>的封装，我们使用的<code>Qt</code>的关于<code>OpenGL</code>封装</p></li>
<li><p>在创建<code>QOpenGLWidget</code>窗口时，在构造函数中添加如下代码：</p>
<p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">QSurfaceFormat format;</span><br><span class="line">format.<span class="built_in">setSamples</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">setFormat</span>(format);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>setFormat</code>是窗口<code>QOpenGLWidget</code>的函数，在构造函数中使用，会给后面所有依赖的小部件设置一个默认的<code>format</code>，对于后面的小部件(窗口)，如果不做格式的修改，将会使用在构造函数中调用<code>setFormat</code>函数设置的格式作为默认格式</li>
</ul></li>
</ul>
<h4 id="失败的尝试">失败的尝试</h4>
<p>
  我尝试，单独修改<code>QopenGLContext</code>的<code>QSurfaceFormat</code>,前面的部分是成功，我获取了当前窗口的<code>QopenGLContext</code>,修改了<code>QSurfaceFormat</code>，向其中添加了
启用<code>MSAA</code>的代码.然后调用<code>QopenGLContext</code>的<code>create</code>函数，企图重新创建一个<code>QopenGLContext</code>，但是失败了，在初始化<code>QopenGLFunction</code>失败，
<p style="color:red">
暂时不知道原因,目测可能需要重新将当前窗口的绑定到重新创建后的上下文，以及调用这个上下文的<code>OpenGL</code>函数
</p>
</p>
]]></content>
      <categories>
        <category>works</category>
        <category>SCU</category>
        <category>Computer Graph</category>
      </categories>
      <tags>
        <tag>OpenGL</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>DepthPeeling</title>
    <url>/2024/01/12/Computer%20Graphics/transparent%20object%20render/OIT/DepthPeeling/</url>
    <content><![CDATA[<h2 id="order-independent-transparency---depthpeeling">Order-independent
transparency - DepthPeeling</h2>
<h4 id="颜色混合">1. 颜色混合</h4>
<p>我们上次说到关于颜色混合的部分:
<a href="./../../ColorBlend/">ColorBlend</a></p>
]]></content>
      <categories>
        <category>Computer Graph</category>
        <category>works</category>
      </categories>
      <tags>
        <tag>OIT</tag>
        <tag>transparent</tag>
      </tags>
  </entry>
  <entry>
    <title>记又一次换工作</title>
    <url>/2025/04/08/Life/2025/%E8%AE%B0%E5%8F%88%E4%B8%80%E6%AC%A1%E6%8D%A2%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<h3 id="记又一次换工作">记又一次换工作</h3>
<p>  三年前，离开北京来到成都，选了在当时看来自己能选的最优的选择。三年后的今天，我又一次启程，离开了工作三年的地方，离开的原因颇为复杂，但我相信也会是最好的选择。</p>
<p>  离开的原因比较复杂，也颇为不舍，仔细想想我并非是舍不得这一份工作，大概是舍不得学校,
和这里美丽的环境。</p>
<p>  在学校的日子过得比较充实，没有虚度光影。值得高兴的事情比较多，这几年遇到很多很有意思的事情，我的生活也很丰富，交到很多朋友，对于生活的态度也有一些改变，总的来说。变得更好了。</p>
<p>  成长总是离不开分别的，所以离开是早晚的事情，况且我觉得我需要去外面历练一番，长久的待在学校会减缓我的成长速度，加上一些客观原因，使得我必须离开这里了，去见识一下社会的险恶，去外出历练一番。</p>
<p>  希望这次离开不是为了离开而离开，祝我好运了！</p>
]]></content>
      <categories>
        <category>works</category>
        <category>interview</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>computer graphics</tag>
        <tag>rendering</tag>
      </tags>
  </entry>
</search>
