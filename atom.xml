<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>RanBun&#39;s Blog</title>
  
  <subtitle>如你所见,如我所见</subtitle>
  <link href="https://blog.ranbun.com/atom.xml" rel="self"/>
  
  <link href="https://blog.ranbun.com/"/>
  <updated>2025-09-04T15:06:52.725Z</updated>
  <id>https://blog.ranbun.com/</id>
  
  <author>
    <name>RanBun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vulkan-Descriptor</title>
    <link href="https://blog.ranbun.com/2025/09/03/Vulkan/Vulkan-Descriptor/"/>
    <id>https://blog.ranbun.com/2025/09/03/Vulkan/Vulkan-Descriptor/</id>
    <published>2025-09-03T15:56:53.000Z</published>
    <updated>2025-09-04T15:06:52.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vulkan---desciptor">Vulkan - Desciptor</h2><h3 id="sources-in-opengl">1. sources in OpenGL</h3><ul><li>与OpenGL不同，Vulkan的所有使用的资源都需要显示的定义，最后把资源放到合适的位置，调用渲染，最后显示出正确的图形。在OpenGL中，有如下Shader代码：</li></ul><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 450 core</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span> <span class="type">vec2</span> TexCoord;</span><br><span class="line"><span class="keyword">uniform</span> sample2D uTexture;</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="type">vec4</span> FragColor;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">vec4</span> tex = <span class="built_in">texture</span>(uTexture, TexCoord);</span><br><span class="line">    FragColor = tex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在CPU端我们需要手动建立一个绑定关系，让CPU的纹理资源绑定到具体的点位，以及让Shader知道应该去哪个点位招对应的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glUseProgram</span>(program);  <span class="comment">/// 绑定shader</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glUniform1i</span>(<span class="built_in">glGetUniformLocation</span>(program, <span class="string">&quot;uTexture&quot;</span>), <span class="number">0</span>); <span class="comment">// 采样器 uTexture → 单元0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">glActiveTexture</span>(GL_TEXTURE0);</span><br><span class="line"><span class="built_in">glBindTexture</span>(GL_TEXTURE_2D, uTexture);    <span class="comment">/// uTexture是我在CPU端创建好的纹理对象</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="source-in-vulkan">source in Vulkan</h3><p>从Vulkan的Shader看起 <figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 相机数据</span></span><br><span class="line"><span class="keyword">layout</span>(set = <span class="number">0</span>, <span class="keyword">binding</span>=<span class="number">0</span>) <span class="keyword">uniform</span> CameraUBO&#123;</span><br><span class="line">    <span class="type">mat4</span> viewProject;</span><br><span class="line">&#125; cam;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set = 1: 模型数据</span></span><br><span class="line"><span class="keyword">layout</span>(set = <span class="number">1</span>, <span class="keyword">binding</span> = <span class="number">0</span>) <span class="keyword">uniform</span> ModelUBO &#123;</span><br><span class="line">    <span class="type">mat4</span> model;</span><br><span class="line">&#125; model;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set = 1: 模型的纹理</span></span><br><span class="line"><span class="keyword">layout</span>(set = <span class="number">1</span>, <span class="keyword">binding</span> = <span class="number">1</span>) <span class="keyword">uniform</span> <span class="type">sampler2D</span> tex;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>首先这个里面有两组编号体系</p><ul><li>set</li><li>binding</li></ul><p>接下来我们就会介绍这两个是两个什么样子的概念.</p><p>从我们的着色器程序片段可以看到，我们定义了三个资源，当这个<code>shader</code>程序在运行的时候，需要知道这三个资源分别在什么地方，或者说，<code>shader</code>需要知道我们去找到这三个资源。</p><p>要完成上述的功能，需要使用<code>Vulkan</code>的描述符集的体系。描述符集有三个比较核心的概念：</p><ul><li><code>VkDescriptorSetLayoutBinding</code>, 定义每一条资源，对应<code>binding</code>的声明</li><li><code>VkDescriptorSetLayout</code>,是由多个<code>VkDescriptorSetLayoutBinding</code>组成，描述一个<code>DescriptorSet</code>,对应<code>shader</code>中的<code>set=x</code>的定义.</li><li><code>VkDescriptorSet</code>,是一个实例，根据<code>VkDescriptorSetLayout</code>这个描述符描述的信息实例化得来，实际要传递给GPU的资源都包含在这个里面。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;vulkan---desciptor&quot;&gt;Vulkan - Desciptor&lt;/h2&gt;
&lt;h3 id=&quot;sources-in-opengl&quot;&gt;1. sources in OpenGL&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;与OpenGL不同，Vulkan的所有使用的资</summary>
      
    
    
    
    
    <category term="Cpp" scheme="https://blog.ranbun.com/tags/Cpp/"/>
    
    <category term="Vulkan" scheme="https://blog.ranbun.com/tags/Vulkan/"/>
    
  </entry>
  
  <entry>
    <title>记又一次换工作</title>
    <link href="https://blog.ranbun.com/2025/04/08/Life/2025/%E8%AE%B0%E5%8F%88%E4%B8%80%E6%AC%A1%E6%8D%A2%E5%B7%A5%E4%BD%9C/"/>
    <id>https://blog.ranbun.com/2025/04/08/Life/2025/%E8%AE%B0%E5%8F%88%E4%B8%80%E6%AC%A1%E6%8D%A2%E5%B7%A5%E4%BD%9C/</id>
    <published>2025-04-08T05:56:25.000Z</published>
    <updated>2025-04-11T06:01:43.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="记又一次换工作">记又一次换工作</h3><p>  三年前，离开北京来到成都，选了在当时看来自己能选的最优的选择。三年后的今天，我又一次启程，离开了工作三年的地方，离开的原因颇为复杂，但我相信也会是最好的选择。</p><p>  离开的原因比较复杂，也颇为不舍，仔细想想我并非是舍不得这一份工作，大概是舍不得学校,和这里美丽的环境。</p><p>  在学校的日子过得比较充实，没有虚度光影。值得高兴的事情比较多，这几年遇到很多很有意思的事情，我的生活也很丰富，交到很多朋友，对于生活的态度也有一些改变，总的来说。变得更好了。</p><p>  成长总是离不开分别的，所以离开是早晚的事情，况且我觉得我需要去外面历练一番，长久的待在学校会减缓我的成长速度，加上一些客观原因，使得我必须离开这里了，去见识一下社会的险恶，去外出历练一番。</p><p>  希望这次离开不是为了离开而离开，祝我好运了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;记又一次换工作&quot;&gt;记又一次换工作&lt;/h3&gt;
&lt;p&gt;  三年前，离开北京来到成都，选了在当时看来自己能选的最优的选择。三年后的今天，我又一次启程，离开了工作三年的地方，离开的原因颇为复杂，但我相信也会是最好的选择。&lt;/p&gt;
&lt;p&gt;  离开的原因比较复杂，也颇为不</summary>
      
    
    
    
    <category term="works" scheme="https://blog.ranbun.com/categories/works/"/>
    
    <category term="interview" scheme="https://blog.ranbun.com/categories/works/interview/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="computer graphics" scheme="https://blog.ranbun.com/tags/computer-graphics/"/>
    
    <category term="rendering" scheme="https://blog.ranbun.com/tags/rendering/"/>
    
  </entry>
  
  <entry>
    <title>ColorBlend</title>
    <link href="https://blog.ranbun.com/2024/01/12/Computer%20Graphics/transparent%20object%20render/ColorBlend/"/>
    <id>https://blog.ranbun.com/2024/01/12/Computer%20Graphics/transparent%20object%20render/ColorBlend/</id>
    <published>2024-01-12T07:33:25.000Z</published>
    <updated>2025-04-10T07:34:26.784Z</updated>
    
    <content type="html"><![CDATA[<h2 id="颜色混合">颜色混合</h2><p>在传统的渲染管线中，如果场景中的所有物体都不透明，那么最终渲染的结果是根据<code>Z-buffer</code>算法比较深度，显示的片元的颜色是离相机的最近的片元的颜色。</p><p>如果场景中存在半透明物体(颜色的<code>alpha</code>值小于<code>1.0</code>)的时候，比如模拟渲染一个透过玻璃观察的场景，正确的场景是我们可以透过玻璃观察到玻璃后面的世界，要正确的渲染这个场景，需要将玻璃的颜色和玻璃后面的场景进行颜色的混合，混合既是混合多种颜色为一种，从而渲染我们认为正确的结果。</p><p>透明物体可以半透明也可以是全透明的，全透明下光线会完全穿透，是指这个透明物体的颜色不参与整个混合，也就是透明物体本身的颜色不对混合的结果有任何的贡献，除去全透明物体剩下的就是半透明物体，半透明物体本身的颜色参与最终颜色的合并，会对生成的结果产生一定的贡献，具体的数量要根据混合算法计算。</p><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/transparent/blending_transparency.png"title="blending transparency" alt="&quot;blending transparency&quot;" /><figcaption aria-hidden="true">"blending transparency"</figcaption></figure><p>在<code>OpenGL</code>中颜色混合一般都是使用<code>ADD</code>的方式,使用片元的<code>alpha</code>作为混合的因子。</p><ul><li><p><code>ADD</code>既是取这两个需要合并的像素，根据因子分别计算一个值<spanclass="math inline">\(C_{src},C_{dst}\)</span>，输出最终的颜色<spanclass="math inline">\(C_{out} = C_{src} +C_{dst}\)</span>，可以分别为<code>RGB</code>通道和<code>alpha</code>通道分别设置混合因子</p></li><li><p><code>ADD</code>被称为混合混合方程，可以分别为<code>RGB</code>通道和<code>alpha</code>通道分别设置混合方程</p></li></ul><p>因为在渲染过程中<code>画家&amp;z-buffer</code>算法的实现方式，当我们有一个半透明的场景，并且我们想要正确显示场景中的物体的颜色，我们必须对场景中的物体进行排序,保证优先渲染最远的物体，此时我们通常可以得到一个正确的渲染结果。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;颜色混合&quot;&gt;颜色混合&lt;/h2&gt;
&lt;p&gt;在传统的渲染管线中，如果场景中的所有物体都不透明，那么最终渲染的结果是根据&lt;code&gt;Z-buffer&lt;/code&gt;算法比较深度，显示的片元的颜色是离相机的最近的片元的颜色。&lt;/p&gt;
&lt;p&gt;如果场景中存在半透明物体(颜色的</summary>
      
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    
  </entry>
  
  <entry>
    <title>DepthPeeling</title>
    <link href="https://blog.ranbun.com/2024/01/12/Computer%20Graphics/transparent%20object%20render/OIT/DepthPeeling/"/>
    <id>https://blog.ranbun.com/2024/01/12/Computer%20Graphics/transparent%20object%20render/OIT/DepthPeeling/</id>
    <published>2024-01-12T07:33:25.000Z</published>
    <updated>2025-04-10T07:34:26.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="order-independent-transparency---depthpeeling">Order-independenttransparency - DepthPeeling</h2><h4 id="颜色混合">1. 颜色混合</h4><p>我们上次说到关于颜色混合的部分:<a href="./../../ColorBlend/">ColorBlend</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;order-independent-transparency---depthpeeling&quot;&gt;Order-independent
transparency - DepthPeeling&lt;/h2&gt;
&lt;h4 id=&quot;颜色混合&quot;&gt;1. 颜色混合&lt;/h4&gt;
&lt;p&gt;我</summary>
      
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    <category term="works" scheme="https://blog.ranbun.com/categories/Computer-Graph/works/"/>
    
    
    <category term="OIT" scheme="https://blog.ranbun.com/tags/OIT/"/>
    
    <category term="transparent" scheme="https://blog.ranbun.com/tags/transparent/"/>
    
  </entry>
  
  <entry>
    <title>切线空间</title>
    <link href="https://blog.ranbun.com/2023/01/16/Computer%20Graphics/%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4/"/>
    <id>https://blog.ranbun.com/2023/01/16/Computer%20Graphics/%E5%88%87%E7%BA%BF%E7%A9%BA%E9%97%B4/</id>
    <published>2023-01-16T01:04:23.000Z</published>
    <updated>2025-04-10T07:34:26.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="法线贴图">法线贴图</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;法线贴图&quot;&gt;法线贴图&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Computer-Graphics/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="texture" scheme="https://blog.ranbun.com/tags/texture/"/>
    
  </entry>
  
  <entry>
    <title>我的2022</title>
    <link href="https://blog.ranbun.com/2023/01/11/Life/2022/%E6%88%91%E7%9A%842022/"/>
    <id>https://blog.ranbun.com/2023/01/11/Life/2022/%E6%88%91%E7%9A%842022/</id>
    <published>2023-01-11T11:41:33.000Z</published>
    <updated>2025-04-10T07:34:27.871Z</updated>
    
    <content type="html"><![CDATA[<ul><li>2022发生了很多事情，关于我的和关于我周围的朋友的，大多都是欢喜的，值得怀念。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;2022发生了很多事情，关于我的和关于我周围的朋友的，大多都是欢喜的，值得怀念。&lt;/li&gt;
&lt;/ul&gt;
</summary>
      
    
    
    
    <category term="bun" scheme="https://blog.ranbun.com/categories/bun/"/>
    
    <category term="life" scheme="https://blog.ranbun.com/categories/bun/life/"/>
    
    
    <category term="mylife" scheme="https://blog.ranbun.com/tags/mylife/"/>
    
  </entry>
  
  <entry>
    <title>反射向量的计算</title>
    <link href="https://blog.ranbun.com/2023/01/09/Math/%E5%8F%8D%E5%B0%84%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2023/01/09/Math/%E5%8F%8D%E5%B0%84%E5%90%91%E9%87%8F%E7%9A%84%E8%AE%A1%E7%AE%97/</id>
    <published>2023-01-09T12:12:10.000Z</published>
    <updated>2025-04-10T07:34:28.158Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
      
      
    <summary type="html">
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Git常用命令-拉取操作</title>
    <link href="https://blog.ranbun.com/2023/01/09/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E6%8B%89%E5%8F%96%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ranbun.com/2023/01/09/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E6%8B%89%E5%8F%96%E6%93%8D%E4%BD%9C/</id>
    <published>2023-01-09T05:47:18.000Z</published>
    <updated>2025-04-10T07:34:27.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git拉取操作"><code>Git</code>拉取操作</h2><ul><li>第一步，我们应该先克隆一个存储库，拥有一个存储库之后我们才可以进行后面的操作</li><li><code>git clone</code> - 克隆远程库</li><li><code>cd ...</code></li></ul><h3 id="查看所有分支">1. 查看所有分支</h3><ul><li>本地与远程的所有分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git branch -a <span class="comment"># 查看本地与远程的所有分支</span></span><br><span class="line">git branch -r <span class="comment"># 查看远程的所有分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上述的两个分支都可以完成查看所有分支的功能</span></span><br></pre></td></tr></table></figure><ul><li>获取所有的远程分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all # 将远程仓库同步到本地,但并不会创建任何可以编辑的分支</span><br></pre></td></tr></table></figure><h3 id="创建与远程分支关联的本地分支">2.创建与远程分支关联的本地分支</h3><ul><li><p>你将要在本地获得一个分支,这个分支和远程的某个分支关联</p></li><li><p>从第一步获取的分支列表中选择一个分支</p></li></ul><h4 id="使用git默认操作">2.1 使用<code>Git</code>默认操作</h4><ul><li>创建与远程分支同名的分支</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">系统自动与远程分支关联</span></span><br><span class="line">git checkout targetBranchName</span><br></pre></td></tr></table></figure><h4 id="创建分支指定远程分支">2.2 创建分支指定远程分支</h4><ul><li>通过<code>git checkout</code>命令参数完成</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b localBranchName origin/targetBranchName </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">使用此命令之后,本地分支localBranchName将与远程分支targetBranchName关联</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">localBranchName 可以与targetBranchName同名也可以不同命,为了方便管理,强烈建议使用相同的名称</span></span><br></pre></td></tr></table></figure><h4 id="指定跟踪的分支">2.3 指定跟踪的分支</h4><ul><li><code>track 远程分支</code></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout --track origin/targetBranchName</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建与远程分支关联的分支</span></span><br></pre></td></tr></table></figure><h4 id="拉取远程分支到本地">2.4 拉取远程分支到本地</h4><ul><li>创建与远程分支关联的本地分支</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -t origin/targetBranchName</span><br></pre></td></tr></table></figure><h4 id="通过git-fetch">2.5 通过<code>Git Fetch</code></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br><span class="line">git fetch [&lt;options&gt;] &lt;group&gt;</span><br><span class="line">git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…​]</span><br><span class="line">git fetch --all [&lt;options&gt;]</span><br></pre></td></tr></table></figure><ul><li><code>options</code>部分建议查阅官方文档</li><li><code>repository</code><ul><li>远程仓库的名字</li><li>也可以是 <code>origin</code></li></ul></li><li>获取远程分支到本地</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git fetch [repo] [targetBranchName]:[localBranchName]   </span><br><span class="line">git fetch origin + origin_test:origin_test <span class="comment">#将远程分支的内容下载到本地并在本地新建分支为origin_test</span></span><br><span class="line">git fetch origin origin_test</span><br><span class="line"><span class="comment"># 此命令执行完后并不会切换到创建的分支,需要手动切换 </span></span><br></pre></td></tr></table></figure><h3 id="编辑代码">3. 编辑代码</h3><ul><li><p><code>do  something</code></p></li><li><p>......</p></li></ul><h3 id="推送代码到远程">4. 推送代码到远程</h3><ul><li>一般情况是先做一次拉取 -<code>git pull or git fetch ......</code></li><li>然后在进行推送 - <code>git push</code></li></ul><h4 id="git-pull">4.1 <code>Git Pull</code></h4><ul><li><code>git pull</code>并不是一个操作,一般是先执行<code>git fetch</code>然后执行一次<code>merge or rebase</code>操作</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git拉取操作&quot;&gt;&lt;code&gt;Git&lt;/code&gt;拉取操作&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一步，我们应该先克隆一个存储库，拥有一个存储库之后我们才可以进行后面的操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git clone&lt;/code&gt; - 克隆远程库&lt;/li&gt;
</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.ranbun.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.ranbun.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令(下)</title>
    <link href="https://blog.ranbun.com/2023/01/05/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%8B/"/>
    <id>https://blog.ranbun.com/2023/01/05/Git/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-%E4%B8%8B/</id>
    <published>2023-01-05T15:06:49.000Z</published>
    <updated>2025-04-10T07:34:27.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git-常用命令下">Git 常用命令(下)</h2><ul><li><p>本节主要介绍rebase相关的操作</p></li><li><p>我们将以具体的功能来处理你相关的事情</p></li></ul><h3 id="rebase简介">1. <code>Rebase</code>简介</h3><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/branch_basic.png"title="branch Basic" alt="branch Basic" /><figcaption aria-hidden="true">branch Basic</figcaption></figure><ul><li>相信你对于两个分支的<code>merge</code>操作并不陌生,整合分支最容易的方法是<code>merge</code>命令。它会把两个分支的最新快照<code>(C3 和 C4)</code>以及二者最近的共同祖先<code>(C2)</code>进行三方合并，合并的结果是生成一个新的快照（并提交）。</li></ul><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/merge_branch_1.png"title="Merge branch" alt="Merge Branch" /><figcaption aria-hidden="true">Merge Branch</figcaption></figure><ul><li><p>你可以提取在 <code>C4</code> 中引入的补丁和修改，然后在<code>C3</code> 的基础上应用一次。 在 <code>Git</code>中，这种操作就叫做 <strong>变基<code>（rebase）</code></strong>。你可以使用 <code>rebase</code>命令将提交到某一分支上的所有修改都移至另一分支上，就好像"重新播放"一样。</p><ul><li>在上述的场景中我们做如下操作便可以成功将<code>experiment</code>分支上的修改<code>C4</code>，应用到<code>master</code>分支上</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout experiment</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><ul><li><p>它的原理是首先找到这两个分支（即当前分支<code>experiment</code>、变基操作的目标基底分支 <code>master</code>）的最近共同祖先<code>C2</code>，然后对比当前分支相对于该祖先的历次提交，<font color=red>提取相应的修改并存为临时文件</font>，然后将当前分支指向目标基底 <code>C3</code>,最后以此将之前另存为临时文件的修改依序应用。</p></li><li><p>它的过程就像下面描述的那样：</p><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/git/basic-rebase-3.png"title="basic rebase 3" alt="Rebase Case" /><figcaption aria-hidden="true">Rebase Case</figcaption></figure></li></ul></li></ul><h3 id="使用rebase合并代码---简单情况">2.使用<code>rebase</code>合并代码 - 简单情况</h3><ul><li><p>切换到你要提取的分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git switch &quot;branchName&quot;</span><br></pre></td></tr></table></figure></li><li><p>使用<code>git rebase</code>将当前分支在与目标分支公共父节点之后的提交提取并应用到目标分支</p><ul><li>当前分支 - <code>experiment</code></li><li>目标分支 - <code>master</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase master</span><br></pre></td></tr></table></figure></li><li><p>如上图所示，会进行如图上的操作</p><ul><li>操作完成后<code>experiment</code>指向 - <code>C4'</code>节点</li></ul></li><li><p>合并<code>experiment</code>的代码到<code>master</code>分支</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git switch master</span><br><span class="line">git merge experiment</span><br></pre></td></tr></table></figure></li><li><p>本此合并完成，同时你可以使用<code>rebase</code>合并之前的提交</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;git-常用命令下&quot;&gt;Git 常用命令(下)&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;本节主要介绍rebase相关的操作&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;我们将以具体的功能来处理你相关的事情&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;rebase简介&quot;&gt;1</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.ranbun.com/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.ranbun.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Normal Matrix</title>
    <link href="https://blog.ranbun.com/2023/01/02/Computer%20Graphics/Normal-Matrix/"/>
    <id>https://blog.ranbun.com/2023/01/02/Computer%20Graphics/Normal-Matrix/</id>
    <published>2023-01-02T15:13:35.000Z</published>
    <updated>2025-04-10T07:34:26.574Z</updated>
    
    <content type="html"><![CDATA[<h2 id="法线矩阵">法线矩阵</h2><ul><li><p>在渲染管线的处理过程中，顶点处理阶段会通过模型变换将局部坐标变换到世界坐标,在模型变换的过程中，顶点会经过旋转、缩放、平移的过程.</p></li><li><p>法线是和方向相关的向量，所以平移对法向这个方向向量是没有意义的，所以我们考虑的是顶点的旋转与缩放对法线的影响，由于法线属于协变矢量(我们将在后面介绍这个概念)的一种，它不能和顶点使用相同的变换矩阵进行变换.</p></li><li><p>为了正确的变换法线，我们必须使用一个和顶点变换矩阵不同的矩阵.</p><ul><li><p>如果矩阵不包含缩放,无疑，它是合适的，可以安全的变换矩阵</p><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_1.png"title="不包含缩放的变换矩阵" alt="不包含缩放的变换" /><figcaption aria-hidden="true">不包含缩放的变换</figcaption></figure></li><li><p>如果矩阵包含均匀的缩放，它仍旧是安全的，依旧可以用来变换法线，唯一需要做的就是，就是变换完成后重新对法线进行归一化.</p><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_2.png"title="均匀缩放矩阵" alt="均匀缩放" /><figcaption aria-hidden="true">均匀缩放</figcaption></figure></li><li><p>如果矩阵包含非均匀的缩放,我们需要一个新的矩阵处理变换后顶点的法相.</p><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_3.png"title="非均匀缩放矩阵" alt="非均匀缩放" /><figcaption aria-hidden="true">非均匀缩放</figcaption></figure></li></ul></li></ul><h3 id="非均匀缩放的法线变换">1. 非均匀缩放的法线变换</h3><ul><li>通常情况下，我们在世界空间计算光照等</li></ul><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/Normal_Matrix_5.png"title="Normal Matrix" alt="Normal Matrix" /><figcaption aria-hidden="true">Normal Matrix</figcaption></figure><ul><li><p>推导：</p></li><li><p><span class="math inline">\(\vec{T}\)</span>表示的是<spanclass="math inline">\(\Delta_{ABC}\)</span>的切向量，由<spanclass="math inline">\(A - C\)</span>计算得到.</p><ul><li><span class="math inline">\(\vec{N} \bot \vec{T}\)</span></li></ul></li><li><p><span class="math inline">\(\vec{T&#39;}\)</span>表示的是<spanclass="math inline">\(\Delta_{A&#39;B&#39;C&#39;}\)</span>的切向量，由<spanclass="math inline">\(A&#39; - C&#39;\)</span>计算得到.</p><ul><li>使用相同的变换矩阵之后，<spanclass="math inline">\(\vec{N&#39;}\cancel{\bot}\vec{T&#39;}\)</span></li></ul></li><li><p>我们使用 <span class="math inline">\(M\)</span>表示模型矩阵</p><ul><li><span class="math inline">\(T = vec4(x,y,z,w)\)</span></li></ul><p><span class="math inline">\(T \times M = (A - C) \timesM\)</span></p><p><span class="math inline">\(T \times M = A \times M - C \timesM\)</span></p><p><span class="math inline">\(T&#39; = A&#39; - C&#39;\)</span></p><ul><li><span class="math inline">\(A&#39; andC&#39;\)</span>是三角形变换后的顶点，所以<spanclass="math inline">\(T&#39;\)</span>仍旧是三角形变换后的切线</li></ul></li><li><p><spanclass="math inline">\(M\)</span>不能用来变换法线，我们只能通过法线<spanclass="math inline">\(\vec{N} \cdot \vec{T} =0\)</span>的性质来完成下面的推导</p><ul><li>可得<span class="math inline">\(\vec{N&#39;} \cdot\vec{T&#39;}\)</span></li><li>法线与切线垂直</li></ul></li><li><p>法线是方向向量，平移对此没有意义，所以我们只考虑模型矩阵的左上角<spanclass="math inline">\(3\times3\)</span>部分矩阵<spanclass="math inline">\(M&#39;\)</span>,并且变换后的法线 <spanclass="math inline">\(\vec{N&#39;}\)</span> 满足<spanclass="math inline">\(\vec{N&#39;} \cdot \vec{T&#39;} =0\)</span></p></li><li><p>在我们不知道一个合适的法线变换的矩阵的时候不妨设它<spanclass="math inline">\(G\)</span></p></li><li><p>此处我们不考虑平移</p></li></ul><h4 id="推导">推导：</h4><p>​ <span class="math inline">\(\vec{N&#39;} \cdot \vec{T&#39;} =(G_{3\times3} \times \vec{N}) \cdot ( M_{3\times3} \times \vec{T} ) =0\)</span></p><p>$ (G_{3} ) ( M_{3} ) = (G_{3} )^T (M_{3} ) $</p><p><spanclass="math inline">\(\vec{N}^TG_{3\times3}^TM_{3\times3}\vec{T} =0\)</span></p><p><span class="math inline">\(\vec{N}^T \times \vec{T} = \vec{N} \cdot\vec{T} = 0\)</span></p><p><span class="math inline">\(G_{3\times3}^TM_{3\times3} == I\)</span>-- 单位矩阵</p><p><span class="math inline">\(G_{3\times3}^T == I *M_{3\times3}^{-1}\)</span></p><p><span class="math inline">\(G_{3\times3} == I * (M_{3\times3}^{-1})^T= (M_{3\times3}^{-1})^T\)</span></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;法线矩阵&quot;&gt;法线矩阵&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在渲染管线的处理过程中，顶点处理阶段会通过模型变换将局部坐标变换到世界坐标,在模型变换的过程中，顶点会经过旋转、缩放、平移的过程.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;法线是和方向相关的向量，所以平移对法向</summary>
      
    
    
    
    <category term="Computer Graph" scheme="https://blog.ranbun.com/categories/Computer-Graph/"/>
    
    
    <category term="OpenGL" scheme="https://blog.ranbun.com/tags/OpenGL/"/>
    
    <category term="math" scheme="https://blog.ranbun.com/tags/math/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL的手动初始化</title>
    <link href="https://blog.ranbun.com/2022/11/03/OpenGL/OpenGL%E7%9A%84%E6%89%8B%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>https://blog.ranbun.com/2022/11/03/OpenGL/OpenGL%E7%9A%84%E6%89%8B%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-11-03T15:35:17.000Z</published>
    <updated>2025-04-10T07:34:28.581Z</updated>
    
    <content type="html"><![CDATA[<h2 id="opengl初始化">OpenGL初始化</h2><ul><li>在使用OpenGL前我们通常需要配置好OpenGL的环境 -创建一个提交命令的客户端，我们需要完成的事情包括如下部分(此处我们介绍关于Windows的操作)：<ul><li>创建一个窗口(for windows)</li><li>获取窗口的<code>Device Context</code></li><li>使用<code>Device Context(HDC)</code>创建<code>OpenGL Render Contesxt(HRLRC)</code></li><li>绑定<code>HDC &amp; HGLRC</code>到当前线程</li></ul></li><li>完成上述的设置之后，便可以调用<code>OpenGL</code>进行渲染</li></ul><h3 id="创建opengl可用的窗口---win">1、创建<code>OpenGL</code>可用的窗口 - <code>Win</code></h3><h4 id="注册窗口类">1.1 注册窗口类</h4><ul><li><code>HINSTANCE</code>对象实例化</li><li>填充<code>WNDCLASS</code>结构体</li><li>注册窗口类</li></ul><h4 id="创建窗口">1.2 创建窗口</h4><h4 id="设置像素格式">1.3 设置像素格式</h4><p><font color=red>loading 待续</font></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;opengl初始化&quot;&gt;OpenGL初始化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在使用OpenGL前我们通常需要配置好OpenGL的环境 -
创建一个提交命令的客户端，我们需要完成的事情包括如下部分(此处我们介绍关于Windows的操作)：
&lt;ul&gt;
&lt;li&gt;创建</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>射线与平面相交</title>
    <link href="https://blog.ranbun.com/2022/10/25/Computer%20Graphics/%E5%B0%84%E7%BA%BF%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/10/25/Computer%20Graphics/%E5%B0%84%E7%BA%BF%E4%B8%8E%E5%B9%B3%E9%9D%A2%E7%9B%B8%E4%BA%A4%E8%AE%A1%E7%AE%97/</id>
    <published>2022-10-25T15:19:53.000Z</published>
    <updated>2025-04-10T07:34:26.919Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算射线与平面的相交">计算射线与平面的相交</h2><ul><li>定义平面</li><li>定义射线</li><li>解方程</li></ul><h3 id="平面方程">1. 平面方程</h3><h4 id="平面方程-1">1.1 平面方程</h4><ul><li><p><span class="math inline">\(p\)</span>为平面上一点，且 <spanclass="math inline">\(p = (x,y,z)\)</span></p></li><li><p>标量表示： $ ax + by + cz = d $</p></li><li><p>矢量表示： $ p = d$</p><ul><li><span class="math inline">\(\vec{n} = [a,b,c]\)</span></li><li>已知任意平面上一点<span class="math inline">\(p\)</span>即可以求得 $d $</li></ul></li><li><p>法线 <span class="math inline">\(\vec{n}\)</span>决定平面的方向</p></li><li><p><span class="math inline">\(d\)</span>定义平面的位置,从原点到平面的有符号的距离</p><ul><li>此距离表示沿着法线方向滑动，法线方向上的测量</li><li><span class="math inline">\(d &gt;0\)</span>,原点位于平面背面，反之位于正面</li></ul></li></ul><h4 id="三个点确定一个平面">1.2 三个点确定一个平面</h4><ul><li>按照不同的坐标表示给出不同顺序的点<ul><li>左手系<ul><li>观察平面的正面，以顺时针给出点的顺序</li></ul></li><li>右手系<ul><li>观察面的正面，以逆时针给出点的顺序</li></ul></li></ul></li><li>点不能共线</li><li>三个点在这个确定的平面上</li></ul><h3 id="射线与平面求交">2. 射线与平面求交</h3><ul><li><p>前处理</p><ul><li>射线与平面是否平行(重合)</li></ul></li><li><p>射线方程</p></li><li><p>平面的表示</p></li><li><p>解方程</p></li></ul><h4 id="射线定义">2.1 射线定义</h4><ul><li><p>定义射线的起点 <span class="math inline">\(P_0 =(x,y,z)\)</span></p></li><li><p>射线的方向<span class="math inline">\(\vec{u}\)</span></p></li><li><p>定义如下: <span class="math inline">\(P = P_0 + t *\vec{u}\)</span></p><ul><li><p><span class="math inline">\(P\)</span>为射线上任意一点</p></li><li><p><span class="math inline">\(t\)</span>为从起点<spanclass="math inline">\(P_0\)</span>沿着方向<spanclass="math inline">\(\vec{u}\)</span>前进的距离</p></li></ul></li></ul><h4 id="平面定义">2.2 平面定义</h4><ul><li><p>已知平面法线与平面上任意向量的点击结果为 <code>0</code></p></li><li><p>取平面上任意点<spanclass="math inline">\(P_1,P_2\)</span>，平面法线 <spanclass="math inline">\(\vec{n}\)</span></p></li><li><p>可得：$ = 0 $</p></li></ul><h4 id="射线与平面的平行计算">2.3 射线与平面的平行计算</h4><figure><imgsrc="https://cdn.jsdelivr.net/gh/Ranbun/images/blog/intersection/Ray_intract_plane.png"title="射线与平面求交" alt="射线与平面求交" /><figcaption aria-hidden="true">射线与平面求交</figcaption></figure><ul><li>判断射线<span class="math inline">\(Ray_2\)</span>与平面的关系<ul><li>起点 <span class="math inline">\(R_2\)</span></li></ul></li></ul><h5 id="平行判定">平行判定</h5><ul><li><span class="math inline">\(Ray_2 \cdot \vec{n} = 0\)</span><ul><li>可知射线<span class="math inline">\(Ray_2\)</span>与平面平行</li></ul></li></ul><h5 id="重合判定">重合判定</h5><ul><li><p>已知平面一点 <span class="math inline">\(P\)</span></p></li><li><p>射线起点<span class="math inline">\(R_2\)</span></p></li><li><p>得：</p><ul><li><span class="math inline">\((P - R_2) \cdot \vec{n} &lt;0\)</span></li><li>可知<span class="math inline">\(R_2\)</span>与点<spanclass="math inline">\(P\)</span>不共面</li><li>可知射线<span class="math inline">\(Ray_2\)</span>与平面平行</li></ul></li></ul><h4 id="相交计算">2.4 相交计算</h4><ul><li><p>除去平行与重合的情况，便只剩下相交与不相交</p></li><li><p>射线 <span class="math inline">\(P = P_0 + t *\vec{u}\)</span></p></li><li><p>平面 $ = 0 $</p></li><li><p>若射线与平面相交，则我们取：</p><ul><li>$ P_1 = P_0 + t * $</li></ul></li></ul><p>=&gt; 带入到平面方程得: <span class="math display">\[(P_2 - (P_0 +t*\vec{u})) \cdot \vec{n} = 0\]</span></p><p><span class="math display">\[(P_2 - P_0) \cdot \vec{n} - t * \vec{u}\cdot \vec{n} = 0\]</span></p><p><span class="math display">\[ t = \frac{ (P_2 - P_0)\cdot\vec{n}}{\vec{u}\cdot\vec{n}}\quad \]</span></p><ul><li>若 <code>t &gt; 0</code>则射线与平面相交，反之不相交</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;计算射线与平面的相交&quot;&gt;计算射线与平面的相交&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;定义平面&lt;/li&gt;
&lt;li&gt;定义射线&lt;/li&gt;
&lt;li&gt;解方程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;平面方程&quot;&gt;1. 平面方程&lt;/h3&gt;
&lt;h4 id=&quot;平面方程-1&quot;&gt;1.</summary>
      
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>AABB与Ray求交</title>
    <link href="https://blog.ranbun.com/2022/09/14/Computer%20Graphics/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/14/Computer%20Graphics/AABB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-14T07:49:17.000Z</published>
    <updated>2025-04-10T07:34:26.417Z</updated>
    
    <content type="html"><![CDATA[<p>光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。<span id="more"></span></p><h2 id="aabb与ray求交">AABB与Ray求交</h2><ul><li>在之前的部分我们说到了关于<code>OBB</code>与<code>Ray</code>求交的计算<a href="./../../08/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/">jump</a>,AABB算是比较特殊的<code>OBB</code>,计算<code>OBB</code>与<code>Ray</code>的方法可能不在适用于<code>AABB</code>与射线的求交计算，当然从原理上来说,这依旧是<code>Slabs Method</code>。</li></ul><h3 id="计算">计算</h3><h4 id="前置判断">前置判断</h4><ul><li>考虑射线起点在盒子里面的情况</li><li>考虑射线和盒子某个面平行的时候</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vec3 begin;<span class="comment">// 射线的起点</span></span><br><span class="line">vec3 u;    <span class="comment">// 射线的方向</span></span><br><span class="line">std::array&lt;vec3,3&gt; normals;  <span class="comment">// 面的三个法线</span></span><br><span class="line">vec3 min,max; <span class="comment">// 盒子的边界点</span></span><br><span class="line"><span class="comment">// 计算是否平行</span></span><br><span class="line"><span class="type">float</span> del = <span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(u[i] &lt; del)  <span class="comment">// 近似为0  向量表示唯一 在这个方向上没有移动表示它和当前轴垂直</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 此时判断射线与盒子的关系</span></span><br><span class="line">        <span class="comment">// 在盒子内部必然相交</span></span><br><span class="line">        <span class="keyword">if</span>(begin[i] &lt; min[i] || begin[i] &gt; max[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><h4id="计算每个方向上对应的slab与射线的相交情况">计算每个方向上对应的<code>slab</code>与射线的相交情况</h4><ul><li><span class="math inline">\(P = P_0 + t \dots \vec{d}\)</span><ul><li><span class="math inline">\(\vec{d}\)</span> - 射线的方向</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> del = <span class="number">1e-6</span>;</span><br><span class="line">vec3 begin;<span class="comment">// 射线的起点</span></span><br><span class="line">vec3 u;    <span class="comment">// 射线的方向</span></span><br><span class="line">std::array&lt;vec3,3&gt; normals;  <span class="comment">// 面的三个法线</span></span><br><span class="line">vec3 min,max; <span class="comment">// 盒子的边界点</span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> tMin = DBL_MIN,tMax = DBL_MAX;  <span class="comment">// 记录最后获取的结果</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> dis = <span class="number">1.0</span> / u[i];</span><br><span class="line">    <span class="type">float</span> t_min;</span><br><span class="line">    <span class="type">float</span> t_max;</span><br><span class="line">    <span class="keyword">if</span>(dis &gt;= del)</span><br><span class="line">    &#123;</span><br><span class="line">        t_max = = (max[i] - begin[i]) * dis;</span><br><span class="line">        t_min = = (min[i] - begin[i]) * dis;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t_max = = (min[i] - begin[i]) * dis;</span><br><span class="line">        t_min = = (max[i] - begin[i]) * dis;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(t_max &lt; t_min)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(t_max,t_min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMin &gt; t_min)</span><br><span class="line">    &#123;</span><br><span class="line">        tMin = t_min;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMax &lt; t_max)</span><br><span class="line">    &#123;</span><br><span class="line">        tMax = t_max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(tMin &gt; tMax)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ture;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="判断">判断</h4><ul><li>返回结果</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="AABB" scheme="https://blog.ranbun.com/tags/AABB/"/>
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>模型变换-模型矩阵计算</title>
    <link href="https://blog.ranbun.com/2022/09/10/Computer%20Graphics/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/09/10/Computer%20Graphics/%E6%A8%A1%E5%9E%8B%E5%8F%98%E6%8D%A2-%E6%A8%A1%E5%9E%8B%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-10T02:56:47.000Z</published>
    <updated>2025-04-10T07:34:26.961Z</updated>
    
    <content type="html"><![CDATA[<p>常规的仿射变换(旋转，缩放，平移),以及一些常用的基本矩阵和这些矩阵的原理<spanclass="math inline">\(\dots\)</span></p><span id="more"></span><h2 id="模型变换">模型变换</h2><ul><li>仿射变换<ul><li>基本概念：</li><li>矩阵的计算</li></ul></li><li>齐次坐标<ul><li>W分量的意义</li></ul></li><li>坐标系的变换<ul><li>模型坐标到世界坐标。</li></ul></li></ul><h3 id="齐次坐标">齐次坐标</h3><ul><li>在开始模型变换的讲解之前，我们首先需要知道，我们的变换的各种操作都是通过矩阵实现的，为了将旋转缩放平移写到一个矩阵中，在计算机图形学中引入了一个叫齐次坐标的东西，给向量<spanclass="math inline">\(\vec{a}_{3\times1}\)</span>扩充一个<code>w</code>维度，<spanclass="math inline">\(\vec{a}(x,y,z,w)\)</span>,关于向量我相信大家知道的不少，向量只表示方向与起点与终点没有关系。当然某些时候我们也用来描述一个空间的位置，所以当<code>w</code>分量为<code>0</code>表示的是向量，为<code>1</code>表示的是一个点，注意：<ul><li><span class="math inline">\(\vec{a}(x,y,z,w)\)</span><code>==</code> <span class="math inline">\(\vec{a}(w \times x,w \timesy,w \times z,w^2)\)</span></li></ul></li></ul><h3 id="平移">平移</h3><ul><li>建模师们在建模的时候都是使用模型自己的坐标，规定坐标系的原点在模型这个包围盒的内部，平移要做的操作就是将模型放到世界空间的某个位置。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;常规的仿射变换(旋转，缩放，平移),
以及一些常用的基本矩阵和这些矩阵的原理&lt;span
class=&quot;math inline&quot;&gt;&#92;(&#92;dots&#92;)&lt;/span&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Computer-Graphics/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="translate" scheme="https://blog.ranbun.com/tags/translate/"/>
    
  </entry>
  
  <entry>
    <title>cmake 文件操作</title>
    <link href="https://blog.ranbun.com/2022/09/10/C++/CMake/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.ranbun.com/2022/09/10/C++/CMake/cmake-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</id>
    <published>2022-09-09T17:36:07.000Z</published>
    <updated>2025-04-10T07:34:26.161Z</updated>
    
    <content type="html"><![CDATA[<p>记录一下在日常的工作中用到的一些<code>cmake</code>的关于文件操作的命令(基本<code>Copy</code>,<code>move</code>,<code>remove</code><spanclass="math inline">\(\dots\)</span>)</p><span id="more"></span><h2 id="cmake-文件操作"><code>cmake</code> 文件操作</h2><ul><li>通常使用<code>FILE</code>命令完成相关的参数.</li></ul><h3 id="copy-file"><code>Copy</code> File</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FILE</span>(&lt;COPY|<span class="keyword">INSTALL</span>&gt; &lt;files&gt;... DESTINATION &lt;dir&gt;</span><br><span class="line">     [FILE_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [DIRECTORY_PERMISSIONS &lt;permissions&gt;...]</span><br><span class="line">     [NO_SOURCE_PERMISSIONS] [USE_SOURCE_PERMISSIONS]</span><br><span class="line">     [FOLLOW_SYMLINK_CHAIN]</span><br><span class="line">     [FILES_MATCHING]</span><br><span class="line">     [[PATTERN &lt;pattern&gt; | REGEX &lt;regex&gt;]</span><br><span class="line">    [EXCLUDE] [PERMISSIONS &lt;permissions&gt;...]] [...])</span><br><span class="line"></span><br><span class="line"><span class="comment"># The COPY signature copies files, directories, and symlinks to a destination folder. </span></span><br><span class="line"><span class="comment"># Relative input paths are evaluated with respect to the current source directory, and a relative destination is evaluated with respect to the current build directory. </span></span><br><span class="line"><span class="comment"># Copying preserves input file timestamps, and optimizes out a file if it exists at the destination with the same timestamp.</span></span><br><span class="line"><span class="comment"># Copying preserves input permissions unless explicit permissions or NO_SOURCE_PERMISSIONS are given (default is USE_SOURCE_PERMISSIONS).</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If FOLLOW_SYMLINK_CHAIN is specified, COPY will recursively resolve the symlinks at the paths given until a real file is found, and install a corresponding symlink in the destination for each symlink encountered.</span></span><br><span class="line"><span class="comment"># For each symlink that is installed, the resolution is stripped of the directory, leaving only the filename, meaning that the new symlink points to a file in the same directory as the symlink. </span></span><br><span class="line"><span class="comment"># This feature is useful on some Unix systems, where libraries are installed as a chain of symlinks with version numbers, with less specific versions pointing to more specific versions. </span></span><br><span class="line"><span class="comment"># FOLLOW_SYMLINK_CHAIN will install all of these symlinks and the library itself into the destination directory. </span></span><br><span class="line"><span class="comment"># For example, if you have the following directory structure:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><code>file</code>命令的<code>copy</code>操作会将文件，目录，或者是符号链接复制到目标目录，相对输入路径是相对于当前源目录(<code>cmake文件</code>)，复制会保留输入文件的时间戳，如果文件存在于目标位置且具有相同的时间戳，则会对其进行优化。复制行为默认保留默认权限，除非手动指定(<code>NO_SOURCE_PERMISSIONS</code>)。</li></ul><h4 id="example">example</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拷贝一个目录(&#123;CMAKE_SOURCE_DIR&#125;/resources/Fonts)到&quot;&#123;CMAKE_SOURCE_DIR&#125;/bin/resources/&quot;路径下</span></span><br><span class="line"><span class="keyword">FILE</span>(COPY <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/resources/Fonts DESTINATION <span class="variable">$&#123;CMAKE_SOURCE_DIR&#125;</span>/bin/resources/)</span><br></pre></td></tr></table></figure><ul><li>load <span class="math inline">\(\dots\)</span> <spanclass="math inline">\(\dots\)</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;记录一下在日常的工作中用到的一些&lt;code&gt;cmake&lt;/code&gt;的关于文件操作的命令(基本&lt;code&gt;Copy&lt;/code&gt;,&lt;code&gt;move&lt;/code&gt;,&lt;code&gt;remove&lt;/code&gt;&lt;span
class=&quot;math inline&quot;&gt;&#92;(&#92;dots&#92;)&lt;/span&gt;)&lt;/p&gt;</summary>
    
    
    
    <category term="CMake" scheme="https://blog.ranbun.com/categories/CMake/"/>
    
    
    <category term="fileSystem" scheme="https://blog.ranbun.com/tags/fileSystem/"/>
    
  </entry>
  
  <entry>
    <title>透视矩阵计算</title>
    <link href="https://blog.ranbun.com/2022/09/08/Computer%20Graphics/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/"/>
    <id>https://blog.ranbun.com/2022/09/08/Computer%20Graphics/%E9%80%8F%E8%A7%86%E7%9F%A9%E9%98%B5%E8%AE%A1%E7%AE%97/</id>
    <published>2022-09-08T13:03:38.000Z</published>
    <updated>2025-04-10T07:34:27.015Z</updated>
    
    <content type="html"><![CDATA[<p>在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？<span id="more"></span></p><h2 id="投影变换">投影变换</h2><ul><li>平行投影</li><li>透视投影</li></ul><center><img id="projection" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/projection.png"/></center><ul><li>当我们完成视图变换<ul><li>相机被移动到世界坐标系的原点，同时场景做了同样的相对位移。</li><li>相机看向<code>-z</code>方向，我们指定了一个<code>up</code>,通过<code>cross</code>我们分别计算出三个轴向，相当远将世界坐标系做一个旋转操作，变换到<spanclass="math inline">\(\vec{right},\vec{up},\vec{look}\)</span> -相机右方向，上方向，观察方向，<font color=red>场景也要做相同的旋转操作</font></li><li>下一步的操作便是投影</li></ul></li><li>此时，我们的场景变换到了相机描述的坐标系下。</li></ul><h3 id="平行投影">1. 平行投影</h3><ul><li>我们最先要做的是定义一个视锥体。<ul><li><span class="math inline">\([left,right]\)</span></li><li><span class="math inline">\([bottom,top]\)</span></li><li><span class="math inline">\([zNear,ZFar]\)</span></li><li><spanclass="math inline">\(ortho(left,right,bottom,top,zNear,zFar)\)</span></li><li><font color=red>由于相机朝向<code>-z</code>,实际上说<code>zNear</code>大于<code>zFar</code></font>.</li></ul></li><li>如上图<a href="#projection">平行投影与透视投影</a>所示：平行投影没有近大远小的视觉效果，我们可以简单的丢掉所有顶点的<code>Z</code>值，将他们挤压到一个平面上，就可以得到一个平面的图。这将会丢掉维度信息，且不可逆，将场景变为二维，同是，对于关于<code>XOY</code>平面对称的点相当不友好[<code>-z,z</code>]，所以并不是一个合适的方法。<ul><li>变换矩阵: <span class="math display">\[  P_0 = \begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 1 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 0 \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \]</span></li></ul></li><li>更好的做法是将场景移动到原点，然后做一次缩放，将场景的所有的顶点的坐标变换到<spanclass="math inline">\((x,y,z) \in [-1,1]^3\)</span><ul><li>此时将会生成 <code>z-buffer</code>，三维场景的信息变为<spanclass="math inline">\([x,y]^2\)</span>的信息</li></ul></li></ul><center><img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/Ortho.png"/></center><center><img id="ortho_1" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer graph/ortho_moveandscale.png"/></center><ul><li>对应矩阵<ul><li><p><code>T matrix</code> <span class="math display">\[  T =  \begin{bmatrix}  1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\  0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\  0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\]</span></p></li><li><p><code>S matrix</code> <span class="math display">\[  S =  \begin{bmatrix}  \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\  0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\  0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\  0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}\]</span></p></li><li><p><code>Ortho Matrix</code> <span class="math display">\[  Ortho =  S \times T =         \begin{bmatrix}      \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp; 0  \\      0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp; 0  \\      0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp; 0  \\      0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \times  \begin{bmatrix}      1 &amp; 0 &amp; 0 &amp; -\frac{left+right}{2}\quad \\      0 &amp; 1 &amp; 0&amp; -\frac{top+bottom}{2}\quad  \\      0 &amp; 0 &amp; 1 &amp; -\frac{zNear+zFar}{2}\quad  \\      0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix} \\  = \begin{bmatrix}          \frac{2}{right - left}\quad &amp; 0 &amp; 0 &amp;-\frac{left+right}{2}\quad  \\          0 &amp; \frac{2}{top - bottom}\quad &amp; 0 &amp;-\frac{top+bottom}{2}\quad  \\          0 &amp; 0 &amp; \frac{2}{zFar - zNear}\quad &amp;-\frac{zNear+zFar}{2}\quad  \\          0 &amp; 0 &amp; 0 &amp; 1  \end{bmatrix}  \]</span></p></li></ul></li></ul><h3 id="透视投影">2. 透视投影</h3><ul><li>透视投影变换的过程可以认为是将透视投影定义的视椎体挤压成一个长方体,然后运用平行投影相似的变换(<code>S + T</code>)<center><img id="projection2ortho" src="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection2ortho.png"/></center></li></ul><h4 id="挤压矩阵计算">2.1. 挤压矩阵计算</h4><p><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/computer%20graph/projection_extrusion_computer.png" />- 如图<a href="#projection2ortho">projection2ortho</a>,从侧面上看: -<span class="math inline">\(\vec{g}\)</span> 指向<code>-Z</code>方向 -<span class="math inline">\(d\)</span> &amp; <spanclass="math inline">\(y_s\)</span>构成的三角形在<spanclass="math inline">\(e\)</span>的角度为<code>fov</code>的一半 -压缩是将<span class="math inline">\(y\)</span>压缩到<spanclass="math inline">\(y_s\)</span></p><h5 id="x_fary_far-to-x_neary_near">2.1.1 <spanclass="math inline">\([X_{far},Y_{far}]\)</span> to <spanclass="math inline">\([X_{near},Y_{near}]\)</span></h5><p><span class="math display">\[        \begin{pmatrix}        x \\        y \\        z \\        \end{pmatrix} *  \begin{bmatrix}        1 &amp; 0 &amp; 0 \\        0 &amp; n &amp; 0 \\        0 &amp; 0 &amp; 1 \\        \end{bmatrix}    = \begin{pmatrix}        x \\        y_s \\        z \\        \end{pmatrix}\]</span></p><ul><li>由三角形相似可以得到: <spanclass="math inline">\(\frac{y_s}{y}\quad=\frac{n}{f}\quad\)</span> =&gt;<span class="math inline">\(y_s = \frac{n}{f}\quad * y\)</span></li><li>同理: <span class="math inline">\(\frac{x_s}{x}\quad\)</span>=$ $=&gt; <span class="math inline">\(x_s = \frac{n}{f}\quad *x\)</span></li></ul><h5 id="挤压过程">2.1.2. 挤压过程</h5><ul><li>将一个点由透视投影的视椎体变换到正交下: <spanclass="math display">\[\begin{pmatrix}      x \\      y \\      z \\      1\end{pmatrix} =&gt; \begin{pmatrix}      \frac{n}{f}\quad*{x} \\      \frac{n}{f}\quad * y \\      {???} \\      1\end{pmatrix} =&gt; \begin{pmatrix}      n * x \\      n * y \\      {???} \\      f\end{pmatrix}\]</span></li></ul><p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =\begin{bmatrix}            n &amp; 0 &amp; 0 &amp; 0 \\            0 &amp; n &amp; 0 &amp; 0  \\        c_1 &amp; c_2 &amp; c_3 &amp; c_4  \\            0 &amp; 0 &amp; 1 &amp; 0        \end{bmatrix}\]</span></p><ul><li>考虑当被变换的这个点在近平面中心上: <spanclass="math display">\[\begin{pmatrix}      n * x \\      n * y \\      {???} \\      f\end{pmatrix}=&gt;  \begin{pmatrix} \\      x \\      y \\      n \\      1  \end{pmatrix} = \begin{pmatrix}      n*x \\      n*y \\      n^2 \\      n\end{pmatrix}\]</span></li></ul><p><span class="math display">\[    Mat4^{(4\times4)}_{p-&gt;o}  * \begin{pmatrix}        x \\        y \\        n \\        1    \end{pmatrix} = \begin{pmatrix}        n*x \\        n*y \\        n^2 \\        n    \end{pmatrix}\]</span></p><p>得到: <span class="math inline">\(c_1 * x + c_2 * y + c_3 * n + c_4 *1 = n^2\)</span> <br> 得到: <span class="math inline">\(c_3 * n + c_4 =n^2\)</span></p><ul><li><p>同理考虑这个点落在远平面的中心: <br> 得到: <spanclass="math inline">\(c_3 * f + c_4 = f^2\)</span></p></li><li><p>解得:</p><ul><li><p><span class="math inline">\(c_3\)</span> <spanclass="math display">\[  c_3 = n + f \\  \]</span></p></li><li><p><span class="math inline">\(c_4\)</span> <spanclass="math display">\[  c_4 = -n * f  \]</span></p></li></ul></li><li><p><spanclass="math inline">\(Mat4^{(4\times4)}_{p-&gt;o}\)</span></p></li></ul><p><span class="math display">\[Mat4^{(4\times4)}_{p-&gt;o} =\begin{bmatrix}            n &amp; 0 &amp; 0 &amp; 0 \\            0 &amp; n &amp; 0 &amp; 0  \\            0 &amp; 0 &amp; n + f &amp; -n*f  \\            0 &amp; 0 &amp; 1 &amp; 0        \end{bmatrix}\]</span></p><h5 id="完整的透视变换矩阵">2.1.3. 完整的透视变换矩阵</h5><ul><li><span class="math inline">\(Mat^{(4\times4)}_{p-&gt;o} *Ortho^{4\times4}_{ortho}\)</span> <span class="math display">\[Mat^{4\times4}_{per} = \begin{bmatrix}              \frac{2*n}{right - left}\quad &amp; 0 &amp; \frac{right +left}{right - left}\quad &amp; -\frac{left+right}{2}\quad  \\              0 &amp; \frac{2*n}{top - bottom}\quad &amp; \frac{top +bottom}{bottom - top}\quad &amp; 0 \\              0 &amp; 0 &amp; \frac{zFar + zNear}{zNear - zFar}\quad&amp; -\frac{2*zFar*zNear}{zFar - zNear}\quad  \\              0 &amp; 0 &amp; 1 &amp; 0      \end{bmatrix}\]</span></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在经过投影变换后，场景由三维变换到二维，这过程如何实现呢？
关于两种不同的投影方式计算生成对应的投影矩阵，该如何计算？</summary>
    
    
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Computer-Graphics/"/>
    
    
    <category term="cpp" scheme="https://blog.ranbun.com/tags/cpp/"/>
    
    <category term="projection" scheme="https://blog.ranbun.com/tags/projection/"/>
    
  </entry>
  
  <entry>
    <title>AABB与Triangle求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/Computer%20Graphics/AABB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/Computer%20Graphics/AABB%E4%B8%8ETriangle%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:49:59.000Z</published>
    <updated>2025-04-10T07:34:26.450Z</updated>
    
    <content type="html"><![CDATA[<p><code>AABB</code>与三角形求交，采用分离轴的方式实现的一种比较优质的方法。 <span id="more"></span></p><h2 id="预备知识">0. 预备知识</h2><h3 id="点到面的距离方程">点到面的距离方程</h3><h3 id="面的方程">面的方程</h3><ul><li>定义平面<code>A</code>的法向 <spanclass="math inline">\(\vec{n}\)</span> <code>&#123;a,b,c&#125;</code>,</li><li>已知平面行一点<span class="math inline">\(P_0 \lbracex_0,y_0,z_0\rbrace\)</span></li><li>任意点 <spanclass="math inline">\(P\)</span><code>&#123;x,y,z&#125;</code></li><li>面方程:<ul><li><span class="math inline">\(\overrightarrow{P - P_0} \cdot \vec{n} =0\)</span></li></ul></li></ul><h3 id="点到面的距离">点到面的距离</h3><h4 id="法向量法">法向量法</h4><ul><li><span class="math inline">\(\vec{n}\)</span> - 平面的法向量</li><li><span class="math inline">\(d\)</span> - 点到平面的距离</li><li><span class="math inline">\(P\)</span> - 平面外一点</li><li><span class="math inline">\(A\)</span> - 平面上一点</li><li>$d = $<ul><li>PA在法向方向上的投影既是点<spanclass="math inline">\(P\)</span>到平面的距离</li></ul></li></ul><h3 id="射线的方程">射线的方程</h3><ul><li>射线方程<ul><li><span class="math inline">\(O\)</span> 为起点， 沿着方向 <spanclass="math inline">\(\vec{d}\)</span></li><li>射线方向上任意一点<span class="math inline">\(P_0\)</span></li><li><span class="math inline">\(P_0 = O + \vec{d}\)</span></li></ul></li></ul><h2 id="三角形与aabb求交">三角形与AABB求交</h2><ul><li>我们定义一个轴对齐包围盒<ul><li>center <span class="math inline">\(c\)</span>,<code>AABB</code>的中心点</li><li>a half vector <span class="math inline">\(\vec{h}\)</span>,记录盒子的各个轴的方向与在轴所在方向大小</li></ul></li><li>一个三角形<ul><li><span class="math inline">\(\Delta u_0u_1u_2\)</span></li></ul></li></ul><p><img id=AABB&Trangle src=https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/AABB_and_trangle_intersect.png></img></p><h3 id="第一步">1. 第一步</h3><ul><li>移动<code>AABB</code>与三角形，使<code>AABB</code>与原点重合</li></ul><h3 id="计算测试的轴">2. 计算测试的轴</h3><ul><li>我们将在原点进行基于分离轴的相交测试，需要测试13根轴。</li></ul><h4 id="aabb的面的法线">2.1 <code>AABB</code>的面的法线</h4><ul><li><span class="math inline">\(\vec{e_0}(1,0,0)\)</span></li><li><span class="math inline">\(\vec{e_1}(0,1,0)\)</span></li><li><span class="math inline">\(\vec{e_2}(0,0,1)\)</span></li></ul><h4 id="三角形delta-u_0u_1u_2的法线">2.2 三角形<spanclass="math inline">\(\Delta u_0u_1u_2\)</span>的法线</h4><ul><li><span class="math inline">\(\vec{n}\)</span></li><li><span class="math inline">\(\vec{n} == \vec{f_0} \times\vec{f_1}\)</span></li></ul><h4 id="a_ij-e_i-times-f_j">2.3 <span class="math inline">\(a_{ij} = e_i\times f_j\)</span></h4><ul><li><span class="math inline">\(i,j \in \left ( 0,1,2 \right)\)</span></li><li><span class="math inline">\(\vec{f_0} = \vec{v_1} -\vec{v_0}\)</span></li><li><span class="math inline">\(\vec{f_1} = \vec{v_2} -\vec{v_1}\)</span></li><li><span class="math inline">\(\vec{f_0} = \vec{v_0} -\vec{v_2}\)</span></li></ul><h3 id="分离轴计算">3 分离轴计算</h3><ul><li><p>一旦找到分离轴算法就会立即停止并且返回一个不相交的结果</p></li><li><p>如果通过所有的测试并且没有找到分离轴，那么三角形与<code>AABB box</code>相交</p></li><li><p>将三角形的顶点投影到每一个分离轴上，然后计算<code>AABB</code>在分离轴上的范围,<code>AABB</code>被移动到原点，它的投影将会是一个<spanclass="math inline">\(\left [ -r,+r\right ]\)</span>对称的</p><ul><li>如果她们在这个分离轴上重合，那么它们投影后的结果也是重合的</li></ul></li><li><p>只有当所有的分离轴上的测试都通过的时候才能是相交的。</p></li></ul><h2 id="code">Code</h2><h3 id="define-aabb">define AABB</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AABB</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">AABB</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">AABB</span><span class="params">(<span class="type">const</span> glm::vec3 &amp; center,<span class="type">const</span> glm::vec3 &amp; size)</span></span></span><br><span class="line"><span class="function">        : m_center(center)</span></span><br><span class="line"><span class="function">        , m_size(size)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateTransfrom</span><span class="params">(<span class="type">const</span> glm::mat4 &amp; model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_center = glm::<span class="built_in">vec3</span>( model * glm::<span class="built_in">vec4</span>(m_center,<span class="number">1.0</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_center;</span><br><span class="line">    glm::vec3 m_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="define-triangle">define Triangle</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Triangle</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/// 注意三角形的顶点顺序为逆时针</span></span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3, <span class="type">const</span> glm::vec3&amp; normal)</span><br><span class="line">        : <span class="built_in">m_p1</span>(p1)</span><br><span class="line">        , <span class="built_in">m_p2</span>(p2)</span><br><span class="line">        , <span class="built_in">m_p3</span>(p3)</span><br><span class="line">        , <span class="built_in">m_normal</span>(glm::<span class="built_in">normalize</span>(normal))</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Triangle</span>(<span class="type">const</span> glm::vec3&amp; p1, <span class="type">const</span> glm::vec3&amp; p2, <span class="type">const</span> glm::vec3&amp; p3)</span><br><span class="line">        : <span class="built_in">m_p1</span>(p1)</span><br><span class="line">        , <span class="built_in">m_p2</span>(p2)</span><br><span class="line">        , <span class="built_in">m_p3</span>(p3)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 计算三角形的法相</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">                p2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">          p3           p1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> v1 = p3 - p1;</span><br><span class="line">        <span class="keyword">auto</span> v2 = p2 - p1;</span><br><span class="line">        m_normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(v2, v1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateTransform</span><span class="params">(glm::mat4 &amp; model)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_p1 = <span class="built_in">vec3</span>(model * glm::<span class="built_in">vec4</span>(m_p1,<span class="number">1.0</span>));</span><br><span class="line">        m_p2 = <span class="built_in">vec3</span>(model * glm::<span class="built_in">vec4</span>(m_p2,<span class="number">1.0</span>));</span><br><span class="line">        m_p3 = <span class="built_in">vec3</span>(model * glm::<span class="built_in">vec4</span>(m_p3,<span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> v1 = m_p3 - m_p1;</span><br><span class="line">        <span class="keyword">auto</span> v2 = m_p2 - m_p1;</span><br><span class="line">        m_normal = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(v2, v1));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 m_p1;</span><br><span class="line">    glm::vec3 m_p2;</span><br><span class="line">    glm::vec3 m_p3;</span><br><span class="line">    glm::vec3 m_normal;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="实现">实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// done </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IntersectAABBWithTriangle</span><span class="params">(<span class="type">const</span> AABB &amp;aabb, <span class="type">const</span> Triangle &amp;triangle)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// move AABB ro  origin</span></span><br><span class="line">    <span class="keyword">auto</span> box = aabb;</span><br><span class="line">    <span class="keyword">auto</span> trans = glm::<span class="built_in">mat4</span>(<span class="number">1.0</span>);</span><br><span class="line">    trans = glm::<span class="built_in">translate</span>(trans,- box.m_center);</span><br><span class="line">    box.<span class="built_in">updateTransfrom</span>(trans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> tri = triangle;</span><br><span class="line">    tri.<span class="built_in">updateTransform</span>(trans);</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,13&gt; projectAxis;</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,3&gt; aabbAxisVector;</span><br><span class="line">    &#123;</span><br><span class="line">        aabbAxisVector[<span class="number">0</span>] = glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbAxisVector[<span class="number">1</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbAxisVector[<span class="number">2</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,3&gt; triEdgeVector;</span><br><span class="line">    &#123;</span><br><span class="line">        triEdgeVector[<span class="number">0</span>] = tri.m_p2 - tri.m_p1;</span><br><span class="line">        triEdgeVector[<span class="number">1</span>] = tri.m_p3 - tri.m_p2;</span><br><span class="line">        triEdgeVector[<span class="number">2</span>] = tri.m_p1 - tri.m_p3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> triangleNormal = tri.m_normal;</span><br><span class="line"></span><br><span class="line">    std::array&lt;glm::vec3,3&gt; aabbFaceNormal;</span><br><span class="line">    &#123;</span><br><span class="line">        aabbFaceNormal[<span class="number">0</span>] = glm::<span class="built_in">vec3</span>(<span class="number">1.0f</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbFaceNormal[<span class="number">1</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">        aabbFaceNormal[<span class="number">2</span>] = glm::<span class="built_in">vec3</span>(<span class="number">0.0f</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 两个图形边的随机组合的叉积也作为一个分离轴</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; i: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">    &#123;  <span class="comment">/// AABB</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; j: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">        &#123; <span class="comment">/// triangle</span></span><br><span class="line">            projectAxis[i*<span class="number">3</span> + j] = glm::<span class="built_in">normalize</span>(glm::<span class="built_in">cross</span>(aabbAxisVector[i], triEdgeVector[j]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三角形的法线</span></span><br><span class="line">    projectAxis[<span class="number">9</span>] = triangleNormal;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; index: &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">    &#123;</span><br><span class="line">        projectAxis[<span class="number">10</span> + index] = aabbFaceNormal[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp; it: projectAxis)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 投影三角形到分离轴上</span></span><br><span class="line">        <span class="keyword">auto</span> p_0 = glm::<span class="built_in">dot</span>(it,tri.m_p1);</span><br><span class="line">        <span class="keyword">auto</span> p_1 = glm::<span class="built_in">dot</span>(it,tri.m_p2);</span><br><span class="line">        <span class="keyword">auto</span> p_2 = glm::<span class="built_in">dot</span>(it,tri.m_p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算AABB的Size</span></span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span> half = glm::<span class="built_in">vec3</span>(<span class="number">0.5</span> * aabb.m_size.x,<span class="number">0.5</span> * aabb.m_size.y,<span class="number">0.5</span> * aabb.m_size.z);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算AABB的投影的结果的范围</span></span><br><span class="line">        <span class="keyword">auto</span> r = half.x * std::<span class="built_in">abs</span>(<span class="built_in">dot</span>(aabbAxisVector[<span class="number">0</span>],it)) +</span><br><span class="line">                half.y * std::<span class="built_in">abs</span>(<span class="built_in">dot</span>(aabbAxisVector[<span class="number">1</span>],it)) +</span><br><span class="line">                half.z * std::<span class="built_in">abs</span>(<span class="built_in">dot</span>(aabbAxisVector[<span class="number">2</span>],it));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算三角形投影结果的范围</span></span><br><span class="line">        <span class="keyword">auto</span> min_p = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(p_0,p_1),p_2);</span><br><span class="line">        <span class="keyword">auto</span> max_p = std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(p_0,p_1),p_2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否相交</span></span><br><span class="line">        <span class="keyword">if</span>(min_p &gt; r || max_p &lt; -r)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;AABB&lt;/code&gt;
与三角形求交，采用分离轴的方式实现的一种比较优质的方法。</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="AABB" scheme="https://blog.ranbun.com/tags/AABB/"/>
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
  </entry>
  
  <entry>
    <title>OBB与Ray求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/Computer%20Graphics/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/Computer%20Graphics/OBB%E4%B8%8ERay%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:49:42.000Z</published>
    <updated>2025-04-10T07:34:26.661Z</updated>
    
    <content type="html"><![CDATA[<p>光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。<span id="more"></span></p><h2 id="obb与ray求交">OBB与Ray求交</h2><ul><li>我们在更之前的地方定义了一个<code>OBB</code>,往前翻一番也许就能找到<ul><li><span class="math inline">\(center\)</span> - 盒子的中心点</li><li><span class="math inline">\(\vec{u}\)</span> - 盒子的某个法线 <spanclass="math inline">\(u\)</span></li><li><span class="math inline">\(\vec{v}\)</span> - 盒子的某个法线 <spanclass="math inline">\(v\)</span></li><li><span class="math inline">\(\vec{w}\)</span> - 盒子的某个法线 <spanclass="math inline">\(w\)</span></li><li>盒子的尺寸 - <span class="math inline">\(size\left(h_u,h_v,h_w\right )\)</span></li></ul></li><li>同样的 我们曾经定义过一条射线<ul><li><span class="math inline">\(Ray \left( P\right ) = O + t \cdot\vec{u}\)</span></li><li><code>Ray(P)</code> 射线上某一点</li><li><code>O</code> 射线的起点</li><li><code>t</code> 沿着方向<spanclass="math inline">\(\vec{u}\)</span>前进的长度</li><li><span class="math inline">\(\vec{u}\)</span> 射线的方向向量</li></ul></li></ul><h2 id="slab-method">slab method</h2><ul><li>在OBB与光线的求交计算中，我们常用的方法是<code>slab method</code><ul><li>将我们测量的这个盒子分成三组平行的板</li><li>分别将光线与对应的板做相交计算，在射线的方向上，有一个进入这一组板的时间<spanclass="math inline">\(t^{min}\)</span>，以及一个出板的时间<spanclass="math inline">\(t^{max}\)</span></li><li>分别计算对于三个面板的<spanclass="math inline">\(t^{min}_{i},t^{max}_{i},i \in\left(u,v,w\right)\)</span></li><li>如果射线与盒子相交，那么简单的说这条射线一定有一段时间是处于这三个<spanclass="math inline">\(t^{min},t^{max}\)</span>之中的。</li></ul></li></ul><h3 id="计算原理">计算原理</h3><figure><imgsrc="https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/Ray_and_Obb_intersect.png"title="Ray&amp;OBB" alt="intersection" /><figcaption aria-hidden="true">intersection</figcaption></figure><ul><li><p><span class="math inline">\(P_{min} = P + t_{min} \cdot\vec{u}\)</span> - <span class="math inline">\(1.0\)</span></p></li><li><p><span class="math inline">\(P_{max} = P + t_{max} \cdot\vec{u}\)</span> - <span class="math inline">\(1.1\)</span></p></li><li><p><span class="math inline">\(P_{i} = P + t \cdot \vec{u}\)</span>- <span class="math inline">\(1.2\)</span></p></li><li><p>$(P_{min} - C ) = min $ - <spanclass="math inline">\(1.3\)</span></p></li><li><p>$(P_{max} - C ) = max $ - <spanclass="math inline">\(1.4\)</span></p></li><li><p><span class="math inline">\(1.0\)</span>式 &amp; <spanclass="math inline">\(1.1\)</span>式 带入 <spanclass="math inline">\(1.3\)</span>式 &amp; <spanclass="math inline">\(1.4\)</span>式得到： <span class="math display">\[\left [ \left (P + t_i \cdot \vec{u} \right ) - C \right ] \cdot\vec{O_n} = O_{Size.j} / 2.0, i \in (min,max),j \in (x,y,z), n \in(u,v,w)\]</span> =&gt; 化简得: <span class="math display">\[t_i = (O_{Size.i} / 2.0 - (C - P) \cdot \vec{O_n}) / (\vec{u} \cdot\vec{O_n}), i \in (min,max),j \in (x,y,z), n \in (u,v,w)\]</span></p></li></ul><h3 id="求交实现">求交实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Intersect::IntersectObbWithRay</span><span class="params">(<span class="type">const</span> OBB&amp; obb, Ray &amp; ray)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> delta = obb.m_center - ray.m_begin; <span class="comment">// C- P</span></span><br><span class="line">    <span class="type">float</span> t1, t2;    <span class="comment">// 当前面交点在射线上的位置</span></span><br><span class="line">    <span class="type">double</span> minT = DBL_MIN, maxT = DBL_MAX;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> e = glm::<span class="built_in">dot</span>(delta, obb.m_u);</span><br><span class="line">        <span class="type">float</span> f = glm::<span class="built_in">dot</span>(ray.m_dir, obb.m_u);</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>) <span class="comment">// 判断当前面是否和射线平行 - 与法线垂直则会平行</span></span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.x / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.x / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)  <span class="comment">// 交换 我们不知道当前的射线与目前检测的板的法相的方向是什么样的关系</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)   <span class="comment">// 未发生相交</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)  <span class="comment">// 小于0表示不再正方向上，盒子在射线的后面</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时盒子与光线平行，我们需要看看盒子和光线的关系，如果光线在盒子内部则相交</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.x / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.x / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> e = glm::<span class="built_in">dot</span>(delta, obb.m_v);</span><br><span class="line">        <span class="type">float</span> f = glm::<span class="built_in">dot</span>(ray.m_dir, obb.m_v);</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.y / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.y / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.y / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.y / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">float</span> e = glm::<span class="built_in">dot</span>(delta, obb.m_w);</span><br><span class="line">        <span class="type">float</span> f = glm::<span class="built_in">dot</span>(ray.m_dir, obb.m_w);</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">abs</span>(f) &gt; <span class="number">1e-20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            t1 = (e + obb.m_size.z / <span class="number">2.0</span>) / f;</span><br><span class="line">            t2 = (e - obb.m_size.z / <span class="number">2.0</span>) / f;</span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; t2)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> temp = t1;</span><br><span class="line">                t1 = t2;</span><br><span class="line">                t2 = temp;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (t1 &gt; minT)</span><br><span class="line">            &#123;</span><br><span class="line">                minT = t1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (t2 &lt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                maxT = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minT &gt; maxT)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxT &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (-e - obb.m_size.z / <span class="number">2.0</span> &gt; <span class="number">0</span> || -e + obb.m_size.z / <span class="number">2.0</span> &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;光先追踪的加速方法就是引入层次结构数据结构，计算光线与层次结构的相交，从而加速光线与场景的求交。</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
    <category term="OBB" scheme="https://blog.ranbun.com/tags/OBB/"/>
    
  </entry>
  
  <entry>
    <title>OBB与OBB求交</title>
    <link href="https://blog.ranbun.com/2022/09/08/Computer%20Graphics/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/"/>
    <id>https://blog.ranbun.com/2022/09/08/Computer%20Graphics/OBB%E4%B8%8EOBB%E6%B1%82%E4%BA%A4/</id>
    <published>2022-09-08T09:28:20.000Z</published>
    <updated>2025-04-10T07:34:26.610Z</updated>
    
    <content type="html"><![CDATA[<p>OBB 全称为 Oriented Bound Box，译为有朝向的包围盒。OBB 常与AABB(Axis-Aligned Bound Box) 对比：AABB 的边与轴平行，而 OBB的边则与物体的朝向有关。</p><span id="more"></span><h3 id="obb求交介绍">OBB求交介绍</h3><ul><li>采用分离轴的方式计算</li><li>两个凸包多边形，当且仅当存在一条线，这两个多边形在这条线上的投影不相交，则这两个多边形也不相交.</li><li>这条线称为<code>Separating Axis</code>.垂直<code>Separating Axis</code>存在一条<code>Separating Line</code>将两个多边形分开。</li></ul><h4 id="obb-to-aabb">OBB to AABB</h4><ul><li>我们采用一个稍微容易理解的方法完成这种计算 -将<code>OBB</code>转换为<code>AABB</code></li><li>然后使用<code>AABB</code>o求交的计算方式去算<code>OBB</code>的相交</li></ul><h3 id="aabb的定义"><code>AABB</code>的定义</h3><ul><li><code>AABB</code>既是<code>Axis-aligned Bounding Box</code></li></ul><center><img src=https://raw.githubusercontent.com/Ranbun/images/main/blog/intersection/define_aabb.png></img></center><ul><li>简单由定义两个最大最小点完成定义，一个<code>OBB</code>也可以描述一个<code>AABB</code></li></ul><h3 id="obb的定义">OBB的定义</h3><ul><li><code>m_center</code> 中点位置</li><li><code>size</code> 盒子的大小(尺寸)</li><li><span class="math inline">\(\vec{u},\vec{v},\vec{w}\)</span>,坐标系的轴向(与面的法相一样)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">OBB</span></span><br><span class="line"><span class="comment">///&lt; 右手系</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">OBB</span>(<span class="type">const</span> vec3 &amp; pos,<span class="type">const</span> vec3 &amp; size)</span><br><span class="line">        : <span class="built_in">m_pos</span>(pos)</span><br><span class="line">        , <span class="built_in">m_size</span>(size)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">OBB</span>(<span class="type">const</span> vec3&amp; pos, <span class="type">const</span> vec3&amp; size, <span class="type">const</span> vec3&amp; u, <span class="type">const</span> vec3&amp; v, <span class="type">const</span> vec3&amp; w)</span><br><span class="line">        : <span class="built_in">m_pos</span>(pos)</span><br><span class="line">        , <span class="built_in">m_size</span>(size) </span><br><span class="line">        , <span class="built_in">m_u</span>(u)</span><br><span class="line">        , <span class="built_in">m_v</span>(v)</span><br><span class="line">        , <span class="built_in">m_w</span>(w)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vec3 m_pos&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;   <span class="comment">///&lt; pos </span></span><br><span class="line">    vec3 m_size&#123; <span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span> &#125;;  <span class="comment">///&lt; 长宽高 x = 长 y = 宽 z = 高</span></span><br><span class="line">    vec3 m_u&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;     <span class="comment">///&lt; x</span></span><br><span class="line">    vec3 m_v&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;     <span class="comment">///&lt; y </span></span><br><span class="line">    vec3 m_w&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;     <span class="comment">///&lt; z </span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="aabb求交"><code>AABB</code>求交</h3><ul><li>根据分离轴定理，对于<code>AABB</code>我们只需要计算最大最小的点在标准的<spanclass="math inline">\({\vec{x},\vec{y},\vec{z}}\)</span>轴上的投影是否相交即可，实现起来比较简单</li></ul><h4 id="code">code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">intersectObbWithObb</span><span class="params">(OBB &amp;first, OBB &amp;second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> fRes  = <span class="built_in">computerOBBIntersecte</span>(first,second);</span><br><span class="line">    <span class="keyword">auto</span> sRes = <span class="built_in">computerOBBIntersecte</span>(second,first);</span><br><span class="line">    <span class="keyword">return</span> (fRes&amp;sRes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">computerOBBIntersecte</span><span class="params">(OBB first, OBB second)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/// first</span></span><br><span class="line">    first.m_trans = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0f</span>),-first.m_center);</span><br><span class="line">    <span class="keyword">auto</span> rotate = glm::<span class="built_in">mat4</span>(glm::<span class="built_in">vec4</span>(first.m_u, <span class="number">0.0</span>), glm::<span class="built_in">vec4</span>(first.m_v, <span class="number">0.0</span>), glm::<span class="built_in">vec4</span>(first.m_w, <span class="number">0.0</span>), glm::<span class="built_in">vec4</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1.0</span>));</span><br><span class="line">    rotate = glm::<span class="built_in">transpose</span>(rotate);</span><br><span class="line">    first.m_rotate = rotate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个matrix变换到第一个变换矩阵描述的空间</span></span><br><span class="line">    first.m_center = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_center,<span class="number">1.0</span>);</span><br><span class="line">    first.m_u = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_u,<span class="number">0.0</span>);</span><br><span class="line">    first.m_v = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_v,<span class="number">0.0</span>);</span><br><span class="line">    first.m_w = first.m_rotate * first.m_trans * glm::<span class="built_in">vec4</span>(first.m_w,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 second 变换到对应的空间中</span></span><br><span class="line">    <span class="keyword">auto</span> trans2Origin = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0</span>),-second.m_center);</span><br><span class="line">    second.m_trans = trans2Origin;</span><br><span class="line">    <span class="keyword">auto</span> transRestore = glm::<span class="built_in">translate</span>(glm::<span class="built_in">mat4</span>(<span class="number">1.0</span>),second.m_center);</span><br><span class="line">    second.m_center = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_center,<span class="number">1.0</span>);</span><br><span class="line">    second.m_u = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_u,<span class="number">0.0</span>);</span><br><span class="line">    second.m_v = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_v,<span class="number">0.0</span>);</span><br><span class="line">    second.m_w = first.m_trans * transRestore * first.m_rotate * second.m_trans * glm::<span class="built_in">vec4</span>(second.m_w,<span class="number">0.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// first Obb max &amp; min position</span></span><br><span class="line">    glm::vec3 fMinPos = first.m_center - first.m_size.x/<span class="number">2.0f</span> * first.m_u - first.m_size.y / <span class="number">2.0f</span> * first.m_v - first.m_size.z/<span class="number">2.0f</span> * first.m_w;</span><br><span class="line">    glm::vec3 fMaxPos = first.m_center + first.m_size.x/<span class="number">2.0f</span> * first.m_u + first.m_size.y / <span class="number">2.0f</span> * first.m_v + first.m_size.z/<span class="number">2.0f</span> * first.m_w;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算second OBB 的最大最小点</span></span><br><span class="line">    std::array&lt;glm::vec3,8&gt; secondPos;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/// 右手系</span></span><br><span class="line">        <span class="comment">// m_center + vector * size</span></span><br><span class="line">        secondPos[<span class="number">0</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                second.m_v * second.m_size.y * <span class="number">0.5f</span> -  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">1</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">2</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> - second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">3</span>] = second.m_center - second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">4</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> -  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">5</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> -</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">6</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> - second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line"></span><br><span class="line">        secondPos[<span class="number">7</span>] = second.m_center + second.m_u * second.m_size.x * <span class="number">0.5f</span> +</span><br><span class="line">                       second.m_v * second.m_size.y * <span class="number">0.5f</span> +  second.m_w * second.m_size.z * <span class="number">0.5f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    glm::vec3 sMinPos&#123;secondPos[<span class="number">0</span>]&#125;;</span><br><span class="line">    glm::vec3 sMaxPos&#123;secondPos[<span class="number">0</span>]&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; it : secondPos)</span><br><span class="line">    &#123;</span><br><span class="line">        sMinPos.x = sMinPos.x &gt; it.x? it.x:sMinPos.x;</span><br><span class="line">        sMinPos.y = sMinPos.y &gt; it.y? it.y:sMinPos.y;</span><br><span class="line">        sMinPos.z = sMinPos.z &gt; it.z? it.z:sMinPos.z;</span><br><span class="line"></span><br><span class="line">        sMaxPos.x = sMaxPos.x &lt; it.x? it.x:sMaxPos.x;</span><br><span class="line">        sMaxPos.y = sMaxPos.y &lt; it.y? it.y:sMaxPos.y;</span><br><span class="line">        sMaxPos.z = sMaxPos.z &lt; it.z? it.z:sMaxPos.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 计算</span></span><br><span class="line">    <span class="keyword">if</span>(</span><br><span class="line">        (fMinPos.x &gt; sMaxPos.x || sMinPos.x &gt; fMaxPos.x) ||</span><br><span class="line">        (fMinPos.y &gt; sMaxPos.y || sMinPos.y &gt; fMaxPos.y) ||</span><br><span class="line">        (fMinPos.z &gt; sMaxPos.z || sMinPos.z &gt; fMaxPos.z)</span><br><span class="line">    )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当然也可以直接使用其他的方式计算<code>OBB</code>的求交，分离轴使用相对较多，可以直接投影<code>OBB</code>的最大最小的点到由<code>OBB</code>确定的投影轴上,包含15跟轴</li><li><code>OBB A</code>的三个轴向,<code>OBB B</code>的三个轴向 6根。</li><li>两个<code>OBB</code>各自轴向的叉积 =&gt; 3*3 = 9。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;OBB 全称为 Oriented Bound Box，译为有朝向的包围盒。OBB 常与
AABB(Axis-Aligned Bound Box) 对比：AABB 的边与轴平行，而 OBB
的边则与物体的朝向有关。&lt;/p&gt;</summary>
    
    
    
    <category term="Algorithm" scheme="https://blog.ranbun.com/categories/Algorithm/"/>
    
    <category term="Computer Graphics" scheme="https://blog.ranbun.com/categories/Algorithm/Computer-Graphics/"/>
    
    
    <category term="Intersect" scheme="https://blog.ranbun.com/tags/Intersect/"/>
    
    <category term="OBB" scheme="https://blog.ranbun.com/tags/OBB/"/>
    
  </entry>
  
  <entry>
    <title>IBL</title>
    <link href="https://blog.ranbun.com/2022/09/08/Computer%20Graphics/IBL/"/>
    <id>https://blog.ranbun.com/2022/09/08/Computer%20Graphics/IBL/</id>
    <published>2022-09-07T17:07:45.000Z</published>
    <updated>2025-04-10T07:34:26.532Z</updated>
    
    <content type="html"><![CDATA[<p>基于图像的照明<code>Image Based Lighting</code> <span id="more"></span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基于图像的照明&lt;code&gt;Image Based Lighting&lt;/code&gt;</summary>
    
    
    
    <category term="rendering" scheme="https://blog.ranbun.com/categories/rendering/"/>
    
    
  </entry>
  
</feed>
